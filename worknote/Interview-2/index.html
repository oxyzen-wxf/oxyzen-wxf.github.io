<!-- build time:Fri Dec 30 2022 00:24:20 GMT+0800 (中国标准时间) --><!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=2"><meta name="theme-color" content="#FFF"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><link rel="icon" type="image/ico" sizes="32x32" href="/images/favicon.ico"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="alternate" type="application/rss+xml" href="https://oxyzen-wxf.github.io/rss.xml"><link rel="alternate" type="application/atom+xml" href="https://oxyzen-wxf.github.io/atom.xml"><link rel="alternate" type="application/json" href="https://oxyzen-wxf.github.io/feed.json"><link rel="stylesheet" href="//fonts.googleapis.com/css?family=Mulish:300,300italic,400,400italic,700,700italic%7CFredericka%20the%20Great:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20JP:300,300italic,400,400italic,700,700italic%7CNoto%20Serif%20SC:300,300italic,400,400italic,700,700italic%7CInconsolata:300,300italic,400,400italic,700,700italic&display=swap&subset=latin,latin-ext"><link rel="stylesheet" href="/css/app.css?v=0.2.5"><meta name="keywords" content="java,interview"><link rel="canonical" href="https://oxyzen-wxf.github.io/worknote/Interview-2/"><title>面试题笔记记录(二)面试必考题（通俗易懂精华版） - Java - 工作日常笔记 | Oxygen Anoxia = = 人生当苦无妨，良人当归即好!</title><meta name="generator" content="Hexo 5.4.0"></head><body itemscope itemtype="http://schema.org/WebPage"><div id="loading"><div class="cat"><div class="body"></div><div class="head"><div class="face"></div></div><div class="foot"><div class="tummy-end"></div><div class="bottom"></div><div class="legs left"></div><div class="legs right"></div></div><div class="paw"><div class="hands left"></div><div class="hands right"></div></div></div></div><div id="container"><header id="header" itemscope itemtype="http://schema.org/WPHeader"><div class="inner"><div id="brand"><div class="pjax"><h1 itemprop="name headline">面试题笔记记录(二)面试必考题（通俗易懂精华版）</h1><div class="meta"><span class="item" title="创建时间：2021-07-10 11:44:55"><span class="icon"><i class="ic i-calendar"></i> </span><span class="text">发表于</span> <time itemprop="dateCreated datePublished" datetime="2021-07-10T11:44:55+08:00">2021-07-10</time> </span><span class="item" title="本文字数"><span class="icon"><i class="ic i-pen"></i> </span><span class="text">本文字数</span> <span>22k</span> <span class="text">字</span> </span><span class="item" title="阅读时长"><span class="icon"><i class="ic i-clock"></i> </span><span class="text">阅读时长</span> <span>20 分钟</span></span></div></div></div><nav id="nav"><div class="inner"><div class="toggle"><div class="lines" aria-label="切换导航栏"><span class="line"></span> <span class="line"></span> <span class="line"></span></div></div><ul class="menu"><li class="item title"><a href="/" rel="start">Oxygen Anoxia</a></li></ul><ul class="right"><li class="item theme"><i class="ic i-sun"></i></li><li class="item search"><i class="ic i-search"></i></li></ul></div></nav></div><div id="imgs" class="pjax"><ul><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclfb3vzhj20zk0m8wny.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipewf5l51j20zk0m8b29.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclgrvbd6j20zk0m8qv5.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclh0m9pdj20zk0m8hdt.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1gipevo9j1jj20zk0m8e81.jpg"></li><li class="item" data-background-image="https://tva3.sinaimg.cn/large/6833939bly1giclhtuo6nj20zk0m8ttm.jpg"></li></ul></div></header><div id="waves"><svg class="waves" xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M-160 44c30 0 58-18 88-18s 58 18 88 18 58-18 88-18 58 18 88 18 v44h-352z"/></defs><g class="parallax"><use xlink:href="#gentle-wave" x="48" y="0"/><use xlink:href="#gentle-wave" x="48" y="3"/><use xlink:href="#gentle-wave" x="48" y="5"/><use xlink:href="#gentle-wave" x="48" y="7"/></g></svg></div><main><div class="inner"><div id="main" class="pjax"><div class="article wrap"><div class="breadcrumb" itemscope itemtype="https://schema.org/BreadcrumbList"><i class="ic i-home"></i> <span><a href="/">首页</a></span><i class="ic i-angle-right"></i> <span itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/worknote/" itemprop="item" rel="index" title="分类于 工作日常笔记"><span itemprop="name">工作日常笔记</span></a><meta itemprop="position" content="1"></span><i class="ic i-angle-right"></i> <span class="current" itemprop="itemListElement" itemscope itemtype="https://schema.org/ListItem"><a href="/categories/worknote/java/" itemprop="item" rel="index" title="分类于 Java"><span itemprop="name">Java</span></a><meta itemprop="position" content="2"></span></div><article itemscope itemtype="http://schema.org/Article" class="post block" lang="zh-CN"><link itemprop="mainEntityOfPage" href="https://oxyzen-wxf.github.io/worknote/Interview-2/"><span hidden itemprop="author" itemscope itemtype="http://schema.org/Person"><meta itemprop="image" content="/images/avatar.jpg"><meta itemprop="name" content="WangXuefeng"><meta itemprop="description" content="人生当苦无妨，良人当归即好!, 日常学习 & 复习记录"></span><span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization"><meta itemprop="name" content=""></span><div class="body md" itemprop="articleBody"><div class="note info"><p>B 站图灵课堂：<span class="exturl" data-url="aHR0cHM6Ly93d3cuYmlsaWJpbGkuY29tL3ZpZGVvL0JWMWFNNHkxVDdQWT9mcm9tPXNlYXJjaCZhbXA7c2VpZD0xMTgwNTk0OTg2MDA4NjI3MjMwMA==">https://www.bilibili.com/video/BV1aM4y1T7PY?from=search&amp;seid=11805949860086272300</span></p></div><h2 id="笔试"><a class="anchor" href="#笔试">#</a> 笔试</h2><h3 id="看一下代码回答问题一"><a class="anchor" href="#看一下代码回答问题一">#</a> 看一下代码回答问题（一）</h3><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre>*   问题：在这中间可以添加 N 行代码，但必须保证 s 引用的指向不变，最终将输出变成 abcd</pre></td></tr><tr><td data-num="3"></td><td><pre> * 核心考的是反射，而不是使用 replace 或者 stringbuilder</pre></td></tr><tr><td data-num="4"></td><td><pre> */</pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="6"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token class-name">String</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 在这中间可以添加 N 行代码，但必须保证 s 引用的指向不变，最终将输出变成 abcd</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token comment">// 利用反射，string 源码中的就是利用属性名为 value 的 char 类型数组组成的我们只需要通过反射来修改属性 value 就好了</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    <span class="token class-name">Field</span> value <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    value<span class="token punctuation">.</span><span class="token function">setAccessible</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    value<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token string">"abcd"</span><span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="看一下代码回答问题二"><a class="anchor" href="#看一下代码回答问题二">#</a> 看一下代码回答问题（二）</h3><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> * 首先 s1 == s2 考察的是 s1 是 new 在堆空间开辟内存空间，s1 指向的是堆内存地址</pre></td></tr><tr><td data-num="3"></td><td><pre> * s2 则是首先判断字符串常量池有没有 abc，有则引用没有则添加到常量池，所以是</pre></td></tr><tr><td data-num="4"></td><td><pre> * s1 == s2 为 false</pre></td></tr><tr><td data-num="5"></td><td><pre> * </pre></td></tr><tr><td data-num="6"></td><td><pre> * 首先了解下 intern 方法，然后理解以后 s2 == s3 为 true 是因为 s1 调用 intern 方法首先</pre></td></tr><tr><td data-num="7"></td><td><pre> * 会去常量池去找引用，而此时 s2 已经在常量池中添加了 abc，所以 s1 的 intern 方法直接把</pre></td></tr><tr><td data-num="8"></td><td><pre> * abc 在常量池的引用给了 s3，所以 s3 等于 s2</pre></td></tr><tr><td data-num="9"></td><td><pre> */</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">review2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token class-name">String</span> s2 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token comment">// s1 == s2  true or false?</span></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// false</span></pre></td></tr><tr><td data-num="17"></td><td><pre></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token comment">//string 对象的 intern 方法，首先会检查字符串常量池中是否存在 "abc"，</span></pre></td></tr><tr><td data-num="19"></td><td><pre>    <span class="token comment">// 如果存在则返回该字符串引用，如果不存在，则把 "abc" 添加到字符串常量中，</span></pre></td></tr><tr><td data-num="20"></td><td><pre>    <span class="token comment">// 并返回该字符串常量的引用。</span></pre></td></tr><tr><td data-num="21"></td><td><pre>    <span class="token class-name">String</span> s3 <span class="token operator">=</span> s1<span class="token punctuation">.</span><span class="token function">intern</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="22"></td><td><pre></pre></td></tr><tr><td data-num="23"></td><td><pre>    <span class="token comment">// s3 == s2  true or false?</span></pre></td></tr><tr><td data-num="24"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s3 <span class="token operator">==</span> s2<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// true</span></pre></td></tr><tr><td data-num="25"></td><td><pre></pre></td></tr><tr><td data-num="26"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h3 id="看一下代码回答问题三"><a class="anchor" href="#看一下代码回答问题三">#</a> 看一下代码回答问题（三）</h3><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> *  原理可以参考 integer 源码，</pre></td></tr><tr><td data-num="3"></td><td><pre> *</pre></td></tr><tr><td data-num="4"></td><td><pre> *  在 interger 类中，存在一个静态内部类 IntegerCache，该类中存在一个 integer cachel，</pre></td></tr><tr><td data-num="5"></td><td><pre> *  并且存在一个 static 块，会在加载类的时候执行，</pre></td></tr><tr><td data-num="6"></td><td><pre> *  会将 - 128 至 127 这些数字提前生成 integer 对象，并缓存在 cache 数组中，当我们在定义 Integer 数字时，</pre></td></tr><tr><td data-num="7"></td><td><pre> *  会调用 IntegerSvalueo 防法，valueo 仿法会判断所定义的数字是否在 - 128 至 127 之间，</pre></td></tr><tr><td data-num="8"></td><td><pre> *  如果存在则直接从 cache 数组中获取 integer 对象，如果超过，则生成一个新的 nteger 对象。</pre></td></tr><tr><td data-num="9"></td><td><pre> */</pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">review3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token class-name">Integer</span> i1 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token comment">// 直接写数字赋值给 i1 等同于 调用了 integer 的 valueof 方法</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token class-name">Integer</span> i2 <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1 <span class="token operator">==</span> i2<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span></pre></td></tr><tr><td data-num="15"></td><td><pre></pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token class-name">Integer</span> i3 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>    <span class="token class-name">Integer</span> i4 <span class="token operator">=</span> <span class="token number">128</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="18"></td><td><pre>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i3 <span class="token operator">==</span> i4<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// false</span></pre></td></tr><tr><td data-num="19"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="string-stringbuffer-stringbuilder区别"><a class="anchor" href="#string-stringbuffer-stringbuilder区别">#</a> String、StringBuffer、StringBuilder 区别</h2><p>1.String 是不可变的，如果尝试去修改，会新生成一个字符串对象，StringBuffer 和 StringBuilder 是可变的 2.StringBuffer 是线程安全的，StringBuilder 是线程不安全的，所以在单线程环境下 StringBuilder 效率会更高</p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token comment">/**</span></pre></td></tr><tr><td data-num="2"></td><td><pre> *String、StringBuffer、StringBuilder 区别</pre></td></tr><tr><td data-num="3"></td><td><pre> *</pre></td></tr><tr><td data-num="4"></td><td><pre> * 1.String 是不可变的，如果尝试去修改，会新生成一个字符串对象，StringBuffer 和 StringBuilder 是可变的</pre></td></tr><tr><td data-num="5"></td><td><pre> * 2.StringBuffer 是线程安全的，StringBuilder 是线程不安全的，所以在单线程环境下 StringBuilder 效率会更高</pre></td></tr><tr><td data-num="6"></td><td><pre> */</pre></td></tr><tr><td data-num="7"></td><td><pre><span class="token annotation punctuation">@Test</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">review4</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token class-name">String</span> s1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre>    s1 <span class="token operator">=</span> <span class="token string">"abcd"</span><span class="token punctuation">;</span>  <span class="token comment">// 即使引用地址不会变化，但是却生成了新的字符串对象</span></pre></td></tr><tr><td data-num="11"></td><td><pre>    </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// StringBuffer StringBuilder 不会生成新的字符串对象</span></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><h2 id="arraylist和linkedlist有哪些区别"><a class="anchor" href="#arraylist和linkedlist有哪些区别">#</a> ArrayList 和 LinkedList 有哪些区别？</h2><ol><li><p>首先，他们的底层数据结构不同，Arraylist 底层是基于数组实现的，LinkedList 底层是基于链表实现的</p></li><li><p>由于底层数据结构不同，他们所适用的场景也不同，Arraylist 更适合随机查找，Linkedlist 更适合删除和添加，查询、添加、删除的时间复杂度不同</p></li><li><p>另外 ArrayList 和 LinkedList 都实现了 List 接口，但是 LinkedList 还额外实现了 Deque 接口，所以 LinkedList 还可以当做队列来使用</p></li></ol><p><strong>Arraylist 底层是基于数组</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>  <span class="token comment">// 基于数组实现的</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>strings<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 该方法由于底层是数组定为索引为 3 特别快，但是由于集合要扩容，还有后面数据索引往后移动，所以 size 越大速度会变慢</span></pre></td></tr></table></figure><p><strong>LinkedList 底层是基于链表</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="2"></td><td><pre>    <span class="token function">linkLast</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="4"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token keyword">void</span> <span class="token function">linkLast</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="6"></td><td><pre>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> l <span class="token operator">=</span> last<span class="token punctuation">;</span>  <span class="token comment">// 链表实现的</span></pre></td></tr><tr><td data-num="7"></td><td><pre>        <span class="token keyword">final</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">></span></span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> e<span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre>        last <span class="token operator">=</span> newNode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="9"></td><td><pre>        <span class="token keyword">if</span> <span class="token punctuation">(</span>l <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span></pre></td></tr><tr><td data-num="10"></td><td><pre>            first <span class="token operator">=</span> newNode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="11"></td><td><pre>        <span class="token keyword">else</span></pre></td></tr><tr><td data-num="12"></td><td><pre>            l<span class="token punctuation">.</span>next <span class="token operator">=</span> newNode<span class="token punctuation">;</span></pre></td></tr><tr><td data-num="13"></td><td><pre>        size<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre>        modCount<span class="token operator">++</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="15"></td><td><pre>    <span class="token punctuation">&#125;</span></pre></td></tr></table></figure><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre>linkedList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 由于底层是链表所以不需要扩容，但是索引需要找到头节点遍历到索引为 3，需要遍历</span></pre></td></tr></table></figure><h2 id="copyonwritearraylist的底层原理是怎样的"><a class="anchor" href="#copyonwritearraylist的底层原理是怎样的">#</a> CopyOnWriteArrayList 的底层原理是怎样的？</h2><ol><li>⾸先 CopyOnWriteArrayList 内部也是⽤过数组来实现的，在向 CopyOnWriteArrayList 添加元素<br>时，会复制⼀个新的数组，写操作在新数组上进⾏，读操作在原数组上进⾏</li><li>并且，写操作会加锁，防⽌出现并发写⼊丢失数据的问题</li><li>写操作结束之后会把原数组指向新数组</li><li>CopyOnWriteArrayList 允许在写操作时来读取数据，⼤⼤提⾼了读的性能，因此适合读多写少的应<br>⽤场景，但是 CopyOnWriteArrayList 会⽐较占内存，同时可能读到的数据不是实时最新的数据，所<br>以不适合实时性要求很⾼的场景</li></ol><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Testpublic</span> <span class="token keyword">void</span> <span class="token function">review6</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> array <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    array<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 多线程高并发的时候，假设 a 线程添加 1，b 线程添加 2，可能会出现 1 添加的呗 b 线程添加的 2 覆盖造成数据丢失    array.add ("2");    CopyOnWriteArrayList&lt;String> list = new CopyOnWriteArrayList&lt;>();    list.add ("");  // 写不会出现数据丢失，因为枷锁了线程写操作需要排队&#125;</span></pre></td></tr></table></figure><p><strong>源代码</strong></p><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">final</span> <span class="token class-name">ReentrantLock</span> lock <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>lock<span class="token punctuation">;</span>  <span class="token comment">// 加锁保证高并发不会出现数据丢失问题    lock.lock ();    try &#123;        Object [] elements = getArray ();   // 获取原数组        int len = elements.length;          Object [] newElements = Arrays.copyOf (elements, len + 1);  // 创建新数组复制并 + 1        newElements [len] = e;   // 赋值        setArray (newElements);  // 重新赋值原数组变为新数组，并且还支持写操作的读，但是由于复制操作        // 读 读的是原数组如果没完成 setArray 方法会读到不是最新数据        return true;    &#125; finally &#123;        lock.unlock ();    &#125;&#125;</span></pre></td></tr></table></figure><h2 id="hashmap中put方法的过程"><a class="anchor" href="#hashmap中put方法的过程">#</a> HashMap 中 put 方法的过程？</h2><ul><li>调用哈希函数获取 <code>Key</code> 对应的 <code>hash</code> 值，再计算其数组下标；</li><li>如果没有出现哈希冲突，则直接放入数组；如果出现哈希冲突，则以链表的方式放在链表后面；</li><li>如果链表长度超过阀值 ( <code>TREEIFYTHRESHOLD==8</code> ), 就把链表转成红黑树，链表长度低于 6, 就把红黑树转回链表；</li><li>如果结点的 <code>key</code> 已经存在，则替换其 <code>value</code> 即可；</li><li>如果集合中的键值对大于 12, 调用 <code>resize</code> 方法进行数组扩容。</li></ul><p><img data-src="../../assets/image-20210802222533959.png" alt="image-20210802222533959"></p><h2 id="说说你对红黑树的见解"><a class="anchor" href="#说说你对红黑树的见解">#</a> 说说你对红黑树的见解？</h2><ul><li>1、每个节点非红即黑</li><li>2、根节点总是黑色的</li><li>3、如果节点是红色的，则它的子节点必须是黑色的 (反之不一定)</li><li>4、每个叶子节点都是黑色的空节点 (NIL 节点)</li><li>5、从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点 (即相同的黑色高度)</li><li><span class="exturl" data-url="aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NjEwNDYyL2FydGljbGUvZGV0YWlscy84MzI3NzUyNA==">https://blog.csdn.net/qq_36610462/article/details/83277524</span></li></ul><h2 id="hashmaplinkedhashmaptreemap有什么区别"><a class="anchor" href="#hashmaplinkedhashmaptreemap有什么区别">#</a> HashMap,LinkedHashMap,TreeMap 有什么区别？</h2><ul><li><code>HashMap</code> 参考其他问题；</li><li><code>LinkedHashMap</code> 保存了记录的插入顺序，在用 <code>Iterator</code> 遍历时，先取到的记录肯定是先插入的；遍历比 <code>HashMap</code> 慢；</li><li><code>TreeMap</code> 实现 <code>SortMap</code> 接口，能够把它保存的记录根据键排序 (默认按键值升序排序，也可以指定排序的比较器)</li></ul><h2 id="hashmap待续"><a class="anchor" href="#hashmap待续">#</a> HashMap 待续...</h2><h2 id="concurrenthashmap"><a class="anchor" href="#concurrenthashmap">#</a> ConcurrentHashMap……</h2><h2 id="threadlocal的底层原理"><a class="anchor" href="#threadlocal的底层原理">#</a> ThreadLocal 的底层原理</h2><ol><li>ThreadLocal 是 Java 中所提供的线程本地存储机制，可以利⽤该机制将数据<strong>缓存在某个线程内部</strong>，<br>该线程可以在任意时刻、任意⽅法中获取缓存的数据</li><li>ThreadLocal 底层是通过<strong> ThreadLocalMap 来实现的</strong>，每个 Thread 对象（注意不是 ThreadLocal 对<br>象）中都存在⼀个<strong> ThreadLocalMap</strong>，Map 的<strong> key</strong> 为<strong> ThreadLocal</strong> 对象，Map 的<strong> value</strong> 为需要缓存的<br><strong>值</strong></li><li>如果在线程池中使⽤ ThreadLocal 会造成内存泄漏，因为当 ThreadLocal 对象使⽤完之后，应该要<br>把设置的 key，value，也就是 Entry 对象进⾏回收，但线程池中的线程不会回收，⽽线程对象是通过<br><strong>强引⽤</strong>指向 ThreadLocalMap，<strong>ThreadLocalMap</strong> 也是通过强引⽤指向 Entry 对象，<strong>线程不被回收</strong>，<br>Entry 对象也就不会被回收，从⽽出现<strong>内存泄漏</strong>，<strong>解决办法是</strong>，在使⽤了 ThreadLocal 对象之后，<strong>⼿</strong><br><strong>动调⽤ ThreadLocal 的 remove ⽅法，⼿动清楚 Entry 对象</strong></li><li>ThreadLocal 经典的应⽤场景就是连接管理（⼀个线程持有⼀个连接，该连接对象可以在不同的⽅<br>法之间进⾏传递，线程之间不共享同⼀个连接）</li></ol><h2 id="如何理解volatile关键字"><a class="anchor" href="#如何理解volatile关键字">#</a> 如何理解 volatile 关键字</h2><p>在并发领域中，存在三⼤特性：原⼦性、有序性、可⻅性。volatile 关键字⽤来修饰对象的属性，在并发 环境下可以保证这个属性的可⻅性，对于加了 volatile 关键字的属性，在对这个属性进⾏修改时，会直接 将 CPU ⾼级缓存中的数据写回到主内存，对这个变量的读取也会直接从主内存中读取，从⽽保证了可⻅ 性，底层是通过操作系统的内存屏障来实现的，由于使⽤了内存屏障，所以会禁⽌指令重排，所以同时 也就保证了有序性，在很多并发场景下，如果⽤好 volatile 关键字可以很好的提⾼执⾏效率。</p><h2 id="reentrantlock中的公平锁和非公平锁的底层实现"><a class="anchor" href="#reentrantlock中的公平锁和非公平锁的底层实现">#</a> ReentrantLock 中的公平锁和⾮公平锁的底层实现</h2><p>⾸先不管是公平锁和⾮公平锁，它们的底层实现都会使⽤ AQS 来进⾏排队，它们的区别在于：线程在使 ⽤ lock () ⽅法加锁时，如果是公平锁，会先检查 AQS 队列中是否存在线程在排队，如果有线程在排队， 则当前线程也进⾏排队，如果是⾮公平锁，则不会去检查是否有线程在排队，⽽是直接竞争锁。</p><p>不管是公平锁还是⾮公平锁，⼀旦没竞争到锁，都会进⾏排队，当锁释放时，都是唤醒排在最前⾯的线 程，所以⾮公平锁只是体现在了线程加锁阶段，⽽没有体现在线程被唤醒阶段。</p><p>另外，ReentrantLock 是可重⼊锁，不管是公平锁还是⾮公平锁都是可重⼊的。</p><h2 id="reentrantlock中trylock和lock方法的区别"><a class="anchor" href="#reentrantlock中trylock和lock方法的区别">#</a> ReentrantLock 中 tryLock () 和 lock () ⽅法的区别</h2><ol><li>tryLock () 表示尝试加锁，可能加到，也可能加不到，该⽅法不会阻塞线程，如果加到锁则返回<br>true，没有加到则返回 false</li><li>lock () 表示阻塞加锁，线程会阻塞直到加到锁，⽅法也没有返回值</li></ol><h2 id="countdownlatch和semaphore的区别和底层原理"><a class="anchor" href="#countdownlatch和semaphore的区别和底层原理">#</a> CountDownLatch 和 Semaphore 的区别和底层原理</h2><p>CountDownLatch 表示计数器，可以给 CountDownLatch 设置⼀个数字，⼀个线程调⽤<br>CountDownLatch 的 await () 将会阻塞，其他线程可以调⽤ CountDownLatch 的 countDown () ⽅法来对<br>CountDownLatch 中的数字减⼀，当数字被减成 0 后，所有 await 的线程都将被唤醒。<br>对应的底层原理就是，调⽤ await () ⽅法的线程会利⽤ AQS 排队，⼀旦数字被减为 0，则会将 AQS 中<br>排队的线程依次唤醒。</p><p>Semaphore 表示信号量，可以设置许可的个数，表示同时允许最多多少个线程使⽤该信号量，通<br>过 acquire () 来获取许可，如果没有许可可⽤则线程阻塞，并通过 AQS 来排队，可以通过 release () ⽅法来释放许可，当某个线程释放了某个许可后，会从 AQS 中正在排队的第⼀个线程开始依次唤 醒，直到没有空闲许可。</p><h2 id="sychronized的偏向锁-轻量级锁-重量级锁"><a class="anchor" href="#sychronized的偏向锁-轻量级锁-重量级锁">#</a> Sychronized 的偏向锁、轻量级锁、重量级锁</h2><ol><li>** 偏向锁：** 在锁对象的对象头中记录⼀下当前获取到该锁的线程 ID，该线程下次如果⼜来获取该锁就<br>可以直接获取到了</li><li>** 轻量级锁：** 由偏向锁升级⽽来，当⼀个线程获取到锁后，此时这把锁是偏向锁，此时如果有第⼆个<br>线程来竞争锁，偏向锁就会升级为轻量级锁，之所以叫轻量级锁，是为了和重量级锁区分开来，轻<br>量级锁底层是通过⾃旋来实现的，并不会阻塞线程</li><li>如果⾃旋次数过多仍然没有获取到锁，则会升级为重量级锁，重量级锁会导致线程阻塞</li><li>** ⾃旋锁：** ⾃旋锁就是线程在获取锁的过程中，不会去阻塞线程，也就⽆所谓唤醒线程，阻塞和唤醒<br>这两个步骤都是需要操作系统去进⾏的，⽐较消耗时间，⾃旋锁是线程通过 CAS 获取预期的⼀个标<br>记，如果没有获取到，则继续循环获取，如果获取到了则表示获取到了锁，这个过程线程⼀直在运<br>⾏中，相对⽽⾔没有使⽤太多的操作系统资源，⽐较轻量。</li></ol><h2 id="sychronized和reentrantlock的区别"><a class="anchor" href="#sychronized和reentrantlock的区别">#</a> Sychronized 和 ReentrantLock 的区别</h2><ol><li>sychronized 是⼀个关键字，ReentrantLock 是⼀个类</li><li>sychronized 会⾃动的加锁与释放锁，ReentrantLock 需要程序员⼿动加锁与释放锁</li><li>sychronized 的底层是 JVM 层⾯的锁，ReentrantLock 是 API 层⾯的锁</li><li>sychronized 是⾮公平锁，ReentrantLock 可以选择公平锁或⾮公平锁</li><li>sychronized 锁的是对象，锁信息保存在对象头中，ReentrantLock 通过代码中 int 类型的 state 标识<br>来标识锁的状态</li><li>sychronized 底层有⼀个锁升级的过程</li></ol><h2 id="线程池的底层工作原理"><a class="anchor" href="#线程池的底层工作原理">#</a> 线程池的底层⼯作原理</h2><p>线程池内部是通过队列 + 线程实现的，当我们利⽤线程池执⾏任务时：</p><ol><li>如果此时线程池中的线程数量⼩于 corePoolSize，即使线程池中的线程都处于空闲状态，也要创建<br>新的线程来处理被添加的任务。</li><li>如果此时线程池中的线程数量等于 corePoolSize，但是缓冲队列 workQueue 未满，那么任务被放⼊<br>缓冲队列。</li><li>如果此时线程池中的线程数量⼤于等于 corePoolSize，缓冲队列 workQueue 满，并且线程池中的数<br>量⼩于 maximumPoolSize，建新的线程来处理被添加的任务。</li><li>如果此时线程池中的线程数量⼤于 corePoolSize，缓冲队列 workQueue 满，并且线程池中的数量等<br>于 maximumPoolSize，那么通过 handler 所指定的策略来处理此任务。</li><li>当线程池中的线程数量⼤于 corePoolSize 时，如果某线程空闲时间超过 keepAliveTime，线程将被<br>终⽌。这样，线程池可以动态的调整池中的线程数</li></ol><h2 id="jvm中哪些是线程共享区"><a class="anchor" href="#jvm中哪些是线程共享区">#</a> JVM 中哪些是线程共享区</h2><p><img data-src="../../assets/image-20210804143116316.png" alt="image-20210804143116316"></p><h2 id="jvm中哪些可以作为gc-root"><a class="anchor" href="#jvm中哪些可以作为gc-root">#</a> JVM 中哪些可以作为 gc root</h2><p>什么是 gc root，JVM 在进⾏垃圾回收时，需要找到 “垃圾” 对象，也就是没有被引⽤的对象，但是直接 找 “垃圾” 对象是⽐较耗时的，所以反过来，先找 “⾮垃圾” 对象，也就是正常对象，那么就需要从某 些 “根” 开始去找，根据这些 “根” 的引⽤路径找到正常对象，⽽这些 “根” 有⼀个特征，就是它只会引⽤其 他对象，⽽不会被其他对象引⽤，例如：栈中的本地变量、⽅法区中的静态变量、本地⽅法栈中的变 量、正在运⾏的线程等可以作为 gc root。</p><h2 id="说说类加载器双亲委派模型"><a class="anchor" href="#说说类加载器双亲委派模型">#</a> 说说类加载器双亲委派模型</h2><p>JVM 中存在三个默认的类加载器：</p><ol><li>BootstrapClassLoader</li><li>ExtClassLoader</li><li>AppClassLoader</li></ol><p>AppClassLoader 的⽗加载器是 ExtClassLoader，ExtClassLoader 的⽗加载器是<br>BootstrapClassLoader。</p><p>JVM 在加载⼀个类时，会调⽤ AppClassLoader 的 loadClass ⽅法来加载这个类，不过在这个⽅法中，会先使⽤ ExtClassLoader 的 loadClass ⽅法来加载类，同样 ExtClassLoader 的 loadClass ⽅法中会先使⽤<br>BootstrapClassLoader 来加载类，如果 BootstrapClassLoader 加载到了就直接成功，如果 BootstrapClassLoader 没有加载到，那么 ExtClassLoader 就会⾃⼰尝试加载该类，如果没有加载到，<br>那么则会由 AppClassLoader 来加载这个类。</p><p>所以，双亲委派指得是，JVM 在加载类时，会委派给 Ext 和 Bootstrap 进⾏加载，如果没加载到才由⾃⼰<br>进⾏加载。</p><h2 id="tomcat中为什么要使用自定义类加载器"><a class="anchor" href="#tomcat中为什么要使用自定义类加载器">#</a> Tomcat 中为什么要使⽤⾃定义类加载器</h2><p>⼀个 Tomcat 中可以部署多个应⽤，⽽每个应⽤中都存在很多类，并且各个应⽤中的类是独⽴的，全类 名是可以相同的，⽐如⼀个订单系统中可能存在 com.zhouyu.User 类，⼀个库存系统中可能也存在 com.zhouyu.User 类，⼀个 Tomcat，不管内部部署了多少应⽤，Tomcat 启动之后就是⼀个 Java 进程， 也就是⼀个 JVM，所以如果 Tomcat 中只存在⼀个类加载器，⽐如默认的 AppClassLoader，那么就只能 加载⼀个 com.zhouyu.User 类，这是有问题的，⽽在 Tomcat 中，<strong>会为部署的每个应⽤都⽣成⼀个类加载 器实例</strong>，名字叫做<strong> WebAppClassLoader</strong>，这样<strong> Tomcat 中每个应⽤就可以使⽤⾃⼰的类加载器去加载⾃ ⼰的类</strong>，从⽽达到应⽤之间的类隔离，不出现冲突。另外 Tomcat 还利⽤⾃定义加载器实现了热加载功 能。</p><h2 id="tomcat如何进行优化"><a class="anchor" href="#tomcat如何进行优化">#</a> Tomcat 如何进⾏优化？</h2><p>对于 Tomcat 调优，可以从两个⽅⾯来进⾏调整：<strong>内存和线程。</strong><br>⾸先启动 Tomcat，实际上就是启动了⼀个<strong> JVM</strong>，所以可以按<strong> JVM 调优</strong>的⽅式来进⾏调整，从⽽达到<br>Tomcat 优化的⽬的。<br>另外 Tomcat 中设计了⼀些<strong>缓存区</strong>，⽐如 appReadBufSize、bufferPoolSize 等缓存区来提⾼吞吐量。<br>还可以<strong>调整 Tomcat 的线程</strong>，⽐如调整<strong> minSpareThreads</strong> 参数来改变 Tomcat<strong> 空闲时</strong>的线程数，调整<br><strong>maxThreads</strong> 参数来设置 Tomcat<strong> 处理连接的最⼤线程数。</strong><br>并且还可以调整 IO 模型，⽐如使⽤ NIO、APR 这种相⽐于 BIO 更加⾼效的 IO 模型。(默认 Tomcat7 使用的是 bio)</p><h2 id="浏览器发出一个请求到收到响应经历了哪些步骤"><a class="anchor" href="#浏览器发出一个请求到收到响应经历了哪些步骤">#</a> 浏览器发出⼀个请求到收到响应经历了哪些步骤？</h2><ol><li>浏览器解析⽤户输⼊的 URL，⽣成⼀个 HTTP 格式的请求</li><li>先根据 URL 域名从本地 hosts ⽂件查找是否有映射 IP，如果没有就将域名发送给电脑所配置的 DNS 进<br>⾏域名解析，得到 IP 地址</li><li>浏览器通过操作系统将请求通过四层⽹络协议发送出去</li><li>途中可能会经过各种路由器、交换机，最终到达服务器</li><li>服务器收到请求后，根据请求所指定的端⼝，将请求传递给绑定了该端⼝的应⽤程序，⽐如 8080 被<br>tomcat 占⽤了</li><li>tomcat 接收到请求数据后，按照 http 协议的格式进⾏解析，解析得到所要访问的 servlet</li><li>然后 servlet 来处理这个请求，如果是 SpringMVC 中的 DispatcherServlet，那么则会找到对应的<br>Controller 中的⽅法，并执⾏该⽅法得到结果</li><li>Tomcat 得到响应结果后封装成 HTTP 响应的格式，并再次通过⽹络发送给浏览器所在的服务器</li><li>浏览器所在的服务器拿到结果后再传递给浏览器，浏览器则负责解析并渲染</li></ol><h2 id="跨域请求是什么有什么问题怎么解决"><a class="anchor" href="#跨域请求是什么有什么问题怎么解决">#</a> 跨域请求是什么？有什么问题？怎么解决？</h2><p>跨域是指浏览器在发起⽹络请求时，会检查该请求所对应的协议、域名、端⼝和当前⽹⻚是否⼀致，如<br>果不⼀致则浏览器会进⾏限制，⽐如在 www.baidu.com 的某个⽹⻚中，如果使⽤ ajax 去访问<br>www.jd.com 是不⾏的，但是如果是 img、iframe、script 等标签的 src 属性去访问则是可以的，之所以浏<br>览器要做这层限制，是为了⽤户信息安全。但是如果开发者想要绕过这层限制也是可以的：</p><ol><li>response 添加 header，⽐如 resp.setHeader (&quot;Access-Control-Allow-Origin&quot;, &quot;*&quot;); 表示可以访问<br>所有⽹站，不受是否同源的限制</li><li>jsonp 的⽅式，该技术底层就是基于 script 标签来实现的，因为 script 标签是可以跨域的</li><li>后台⾃⼰控制，先访问同域名下的接⼝，然后在接⼝中再去使⽤ HTTPClient 等⼯具去调⽤⽬标接⼝</li><li>⽹关，和第三种⽅式类似，都是交给后台服务来进⾏跨域访问</li></ol><h2 id="spring中的bean创建的生命周期有哪些步骤"><a class="anchor" href="#spring中的bean创建的生命周期有哪些步骤">#</a> Spring 中的 Bean 创建的⽣命周期有哪些步骤</h2><p>Spring 中⼀个 Bean 的创建⼤概分为以下⼏个步骤：</p><ol><li>推断构造⽅法</li><li>实例化</li><li>填充属性，也就是依赖注⼊</li><li>处理 Aware 回调</li><li>初始化前，处理 @PostConstruct 注解</li><li>初始化，处理 InitializingBean 接⼝</li><li>初始化后，进⾏ AOP</li></ol><p><img data-src="../../assets/image-20210804154634179.png" alt="image-20210804154634179"></p><h2 id="spring中bean是线程安全的吗"><a class="anchor" href="#spring中bean是线程安全的吗">#</a> Spring 中 Bean 是线程安全的吗</h2><p>Spring 本身并没有针对 Bean 做线程安全的处理，所以：</p><ol><li>如果 Bean 是⽆状态的，那么 Bean 则是线程安全的</li><li>如果 Bean 是有状态的，那么 Bean 则不是线程安全的<br>另外，Bean 是不是线程安全，跟 Bean 的作⽤域没有关系，Bean 的作⽤域只是表示 Bean 的⽣命周期范<br>围，对于任何⽣命周期的 Bean 都是⼀个对象，这个对象是不是线程安全的，还是得看这个 Bean 对象本<br>身。</li></ol><h2 id="applicationcontext和beanfactory有什么区别"><a class="anchor" href="#applicationcontext和beanfactory有什么区别">#</a> ApplicationContext 和 BeanFactory 有什么区别</h2><p>BeanFactory 是 Spring 中⾮常核⼼的组件，表示 Bean ⼯⼚，可以⽣成 Bean，维护 Bean，⽽ ApplicationContext 继承了 BeanFactory，所以 ApplicationContext 拥有 BeanFactory 所有的特点，也 是⼀个 Bean ⼯⼚，但是 ApplicationContext 除开继承了 BeanFactory 之外，还继承了诸如 EnvironmentCapable、MessageSource、ApplicationEventPublisher 等接⼝，从⽽ ApplicationContext 还有获取系统环境变量、国际化、事件发布等功能，这是 BeanFactory 所不具备的</p><h2 id="spring中的事务是如何实现的"><a class="anchor" href="#spring中的事务是如何实现的">#</a> Spring 中的事务是如何实现的</h2><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>timeout <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">)</span> <span class="token comment">//a 事务  b 会随 a 的超时时间不会用自己的子事务无效  （同一个 service 调用 bc 方法其实还是共用一个事务）</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">a</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token comment">// （同一个 service 调用 bc 方法其实还是共用一个事务）</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token class-name">OrderServiceImpl</span> o <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">OrderServiceImpl</span><span class="token punctuation">)</span> <span class="token class-name">AopContext</span><span class="token punctuation">.</span><span class="token function">currentProxy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="5"></td><td><pre>    o<span class="token punctuation">.</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//a 事务</span></pre></td></tr><tr><td data-num="6"></td><td><pre>    o<span class="token punctuation">.</span><span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 新事务  （不随 a 回滚）</span></pre></td></tr><tr><td data-num="7"></td><td><pre>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="8"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="9"></td><td><pre></pre></td></tr><tr><td data-num="10"></td><td><pre><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRED<span class="token punctuation">,</span>timeout <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment">// 需要一个事务：如果前面有了就公用一个事务</span></pre></td></tr><tr><td data-num="11"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">b</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr><tr><td data-num="12"></td><td><pre></pre></td></tr><tr><td data-num="13"></td><td><pre><span class="token annotation punctuation">@Transactional</span><span class="token punctuation">(</span>propagation <span class="token operator">=</span> <span class="token class-name">Propagation</span><span class="token punctuation">.</span>REQUIRES_NEW<span class="token punctuation">)</span> <span class="token comment">// 需要一个新的事务，自己用一个事务</span></pre></td></tr><tr><td data-num="14"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">c</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><ol><li>Spring 事务底层是基于数据库事务和 AOP 机制的</li><li>⾸先对于使⽤了 @Transactional 注解的 Bean，Spring 会创建⼀个代理对象作为 Bean</li><li>当调⽤代理对象的⽅法时，会先判断该⽅法上是否加了 @Transactional 注解</li><li>如果加了，那么则利⽤事务管理器创建⼀个数据库连接</li><li>并且修改数据库连接的 autocommit 属性为 false，禁⽌此连接的⾃动提交，这是实现 Spring 事务⾮<br>常重要的⼀步</li></ol><h2 id="spring中什么时候transactional会失效"><a class="anchor" href="#spring中什么时候transactional会失效">#</a> Spring 中什么时候 @Transactional 会失效</h2><p>因为 Spring 事务是基于代理来实现的，所以某个加了 @Transactional 的⽅法<strong>只有是被代理对象调⽤时</strong>， 那么这个<strong>注解才会⽣效</strong>，所以如果是被代理对象来调⽤这个⽅法，那么 @Transactional 是不会失效的。</p><p>（比如自己 new 一个不用依赖注入就不会生效）</p><p>同时如果某个⽅法是<strong> private</strong> 的，那么 @Transactional 也会失效，<strong>因为底层 cglib 是基于⽗⼦类来实现 的，⼦类是不能重载⽗类的 private ⽅法的</strong>，所以⽆法很好的利⽤代理，也会<strong>导致 @Transactianal 失效</strong></p><h2 id="spring容器启动流程是怎样的"><a class="anchor" href="#spring容器启动流程是怎样的">#</a> Spring 容器启动流程是怎样的</h2><ol><li>在创建 Spring 容器，也就是启动 Spring 时：</li><li>⾸先会进⾏扫描，扫描得到所有的 BeanDefinition 对象，并存在⼀个 Map 中</li><li>然后筛选出⾮懒加载的单例 BeanDefinition 进⾏创建 Bean，对于多例 Bean 不需要在启动过程中去<br>进⾏创建，对于多例 Bean 会在每次获取 Bean 时利⽤ BeanDefinition 去创建</li><li>利⽤ BeanDefinition 创建 Bean 就是 Bean 的创建⽣命周期，这期间包括了合并 BeanDefinitio<br>构造⽅法、实例化、属性填充、初始化前、初始化、初始化后等步骤，其中 AOP 就是发⽣在初始化<br>后这⼀步骤中</li><li>单例 Bean 创建完了之后，Spring 会发布⼀个容器启动事件</li><li>Spring 启动结束</li><li>在源码中会更复杂，⽐如源码中会提供⼀些模板⽅法，让⼦类来实现，⽐如源码中还涉及到⼀些<br>BeanFactoryPostProcessor 和 BeanPostProcessor 的注册，Spring 的扫描就是通过<br>BenaFactoryPostProcessor 来实现的，依赖注⼊就是通过 BeanPostProcessor 来实现的</li><li>在 Spring 启动过程中还会去处理 @Import 等注解</li></ol><h2 id="spring用到了哪些设计模式"><a class="anchor" href="#spring用到了哪些设计模式">#</a> Spring ⽤到了哪些设计模式</h2><p><img data-src="../../assets/image-20210804161449340.png" alt="image-20210804161449340"></p><h2 id="springmvc的底层工作流程"><a class="anchor" href="#springmvc的底层工作流程">#</a> SpringMVC 的底层⼯作流程</h2><ol><li>⽤户发送请求⾄前端控制器 DispatcherServlet。</li><li>DispatcherServlet 收到请求调⽤ HandlerMapping 处理器映射器。</li><li>处理器映射器找到具体的处理器 (可以根据 xml 配置、注解进⾏查找)，⽣成处理器及处理器拦截器<br>(如果有则⽣成) ⼀并返回给 DispatcherServlet。</li><li>DispatcherServlet 调⽤ HandlerAdapter 处理器适配器。</li><li>HandlerAdapter 经过适配调⽤具体的处理器 (Controller，也叫后端控制器)</li><li>Controller 执⾏完成返回 ModelAndView。</li><li>HandlerAdapter 将 controller 执⾏结果 ModelAndView 返回给 DispatcherServle</li><li>DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。</li><li>ViewReslover 解析后返回具体 View。</li><li>DispatcherServlet 根据 View 进⾏渲染视图（即将模型数据填充⾄视图中）。</li></ol><h2 id="spring-refresh"><a class="anchor" href="#spring-refresh">#</a> Spring refresh</h2><figure class="highlight java"><figcaption data-lang="java"></figcaption><table><tr><td data-num="1"></td><td><pre><span class="token annotation punctuation">@Override</span></pre></td></tr><tr><td data-num="2"></td><td><pre><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">refresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeansException</span><span class="token punctuation">,</span> <span class="token class-name">IllegalStateException</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="3"></td><td><pre>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>startupShutdownMonitor<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="4"></td><td><pre>    <span class="token comment">// 准备，记录容器的启动时间 startupDate, 标记容器为激活，初始化上下文环境如文件路径信息，验证必填属性是否填写 </span></pre></td></tr><tr><td data-num="5"></td><td><pre>    <span class="token function">prepareRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="6"></td><td><pre> </pre></td></tr><tr><td data-num="7"></td><td><pre> </pre></td></tr><tr><td data-num="8"></td><td><pre>    <span class="token comment">// 这步比较重要 (解析)，告诉子类去刷新 bean 工厂，这步完成后配置文件就解析成一个个 bean 定义，注册到 BeanFactory（但是未被初始化，仅将信息写到了 beanDefination 的 map 中）</span></pre></td></tr><tr><td data-num="9"></td><td><pre>    <span class="token class-name">ConfigurableListableBeanFactory</span> beanFactory <span class="token operator">=</span> <span class="token function">obtainFreshBeanFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="10"></td><td><pre> </pre></td></tr><tr><td data-num="11"></td><td><pre> </pre></td></tr><tr><td data-num="12"></td><td><pre>    <span class="token comment">// 设置 beanFactory 类加载器，添加多个 beanPostProcesser</span></pre></td></tr><tr><td data-num="13"></td><td><pre>    <span class="token function">prepareBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="14"></td><td><pre> </pre></td></tr><tr><td data-num="15"></td><td><pre> </pre></td></tr><tr><td data-num="16"></td><td><pre>    <span class="token keyword">try</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="17"></td><td><pre>        <span class="token comment">// 允许子类上下文中对 beanFactory 做后期处理</span></pre></td></tr><tr><td data-num="18"></td><td><pre>        <span class="token function">postProcessBeanFactory</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="19"></td><td><pre> </pre></td></tr><tr><td data-num="20"></td><td><pre> </pre></td></tr><tr><td data-num="21"></td><td><pre>        <span class="token comment">// 调用 BeanFactoryPostProcessor 各个实现类的方法</span></pre></td></tr><tr><td data-num="22"></td><td><pre>        <span class="token function">invokeBeanFactoryPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="23"></td><td><pre> </pre></td></tr><tr><td data-num="24"></td><td><pre> </pre></td></tr><tr><td data-num="25"></td><td><pre>        <span class="token comment">// 注册 BeanPostProcessor 的实现类，注意看和 BeanFactoryPostProcessor 的区别</span></pre></td></tr><tr><td data-num="26"></td><td><pre>         <span class="token comment">// 此接口两个方法: postProcessBeforeInitialization 和 postProcessAfterInitialization</span></pre></td></tr><tr><td data-num="27"></td><td><pre>         <span class="token comment">// 两个方法分别在 Bean 初始化之前和初始化之后得到执行。注意，到这里 Bean 还没初始化</span></pre></td></tr><tr><td data-num="28"></td><td><pre>        <span class="token function">registerBeanPostProcessors</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="29"></td><td><pre> </pre></td></tr><tr><td data-num="30"></td><td><pre> </pre></td></tr><tr><td data-num="31"></td><td><pre>        <span class="token comment">// 初始化 ApplicationContext 的 MessageSource</span></pre></td></tr><tr><td data-num="32"></td><td><pre>        <span class="token function">initMessageSource</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="33"></td><td><pre> </pre></td></tr><tr><td data-num="34"></td><td><pre> </pre></td></tr><tr><td data-num="35"></td><td><pre>        <span class="token comment">// 初始化 ApplicationContext 事件广播器</span></pre></td></tr><tr><td data-num="36"></td><td><pre>        <span class="token function">initApplicationEventMulticaster</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="37"></td><td><pre> </pre></td></tr><tr><td data-num="38"></td><td><pre> </pre></td></tr><tr><td data-num="39"></td><td><pre>        <span class="token comment">// 初始化子类特殊 bean（钩子方法）</span></pre></td></tr><tr><td data-num="40"></td><td><pre>        <span class="token function">onRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="41"></td><td><pre> </pre></td></tr><tr><td data-num="42"></td><td><pre> </pre></td></tr><tr><td data-num="43"></td><td><pre>        <span class="token comment">// 注册事件监听器</span></pre></td></tr><tr><td data-num="44"></td><td><pre>        <span class="token function">registerListeners</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="45"></td><td><pre> </pre></td></tr><tr><td data-num="46"></td><td><pre> </pre></td></tr><tr><td data-num="47"></td><td><pre>        <span class="token comment">// 初始化所有 singleton bean  重点！！重点！！</span></pre></td></tr><tr><td data-num="48"></td><td><pre>        <span class="token function">finishBeanFactoryInitialization</span><span class="token punctuation">(</span>beanFactory<span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="49"></td><td><pre> </pre></td></tr><tr><td data-num="50"></td><td><pre> </pre></td></tr><tr><td data-num="51"></td><td><pre>        <span class="token comment">// 广播事件，ApplicationContext 初始化完成</span></pre></td></tr><tr><td data-num="52"></td><td><pre>        <span class="token function">finishRefresh</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></pre></td></tr><tr><td data-num="53"></td><td><pre><span class="token punctuation">&#125;</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">BeansException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span></pre></td></tr><tr><td data-num="54"></td><td><pre><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></pre></td></tr><tr><td data-num="55"></td><td><pre><span class="token punctuation">&#125;</span></pre></td></tr></table></figure><p>1、prepareRefresh();<br>容器刷新前的准备，设置上下文状态，获取属性，验证必要的属性等</p><p>2、ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();<br>获取新的 beanFactory，销毁原有 beanFactory、为每个 bean 生成 BeanDefinition 等</p><p>3、prepareBeanFactory(beanFactory);<br>配置标准的 beanFactory，设置 ClassLoader，设置 SpEL 表达式解析器等</p><p>4、postProcessBeanFactory(beanFactory);<br>模板方法，允许在子类中对 beanFactory 进行后置处理。</p><p>5、invokeBeanFactoryPostProcessors(beanFactory);<br>实例化并调用所有注册的 beanFactory 后置处理器（实现接口 BeanFactoryPostProcessor 的 bean，在 beanFactory 标准初始化之后执行）。<br>例如:<br>PropertyPlaceholderConfigurer (处理占位符)</p><p>6、registerBeanPostProcessors(beanFactory);<br>实例化和注册 beanFactory 中扩展了 BeanPostProcessor 的 bean。<br>例如：<br>AutowiredAnnotationBeanPostProcessor (处理被 @Autowired 注解修饰的 bean 并注入)<br>RequiredAnnotationBeanPostProcessor (处理被 @Required 注解修饰的方法)<br>CommonAnnotationBeanPostProcessor (处理 @PreDestroy、@PostConstruct、@Resource 等多个注解的作用) 等。</p><p>7、initMessageSource();<br>初始化国际化工具类 MessageSource</p><p>8、initApplicationEventMulticaster();<br>初始化时间广播器</p><p>9、onRefresh();<br>模板方法，在容器刷新的时候可以自定义逻辑，不同的 Spring 容器做不同的事情。</p><p>10、registerListeners();<br>注册监听器，广播 early application events</p><p>11、finishBeanFactoryInitialization(beanFactory);<br>实例化所有剩余的（非懒加载）单例<br>比如 invokeBeanFactoryPostProcessors 方法中根据各种注解解析出来的类，在这个时候都会被初始化。<br>实例化的过程各种 BeanPostProcessor 开始起作用。</p><p>12、finishRefresh();<br>refresh 做完之后需要做的其他事情。<br>清除上下文资源缓存（如扫描中的 ASM 元数据）<br>初始化上下文的生命周期处理器，并刷新（找出 Spring 容器中实现了 Lifecycle 接口的 bean 并执行 start () 方法）。<br>发布 ContextRefreshedEvent 事件告知对应的 ApplicationListener 进行响应的操作</p><h2 id="springboot中常用注解及其底层实现"><a class="anchor" href="#springboot中常用注解及其底层实现">#</a> SpringBoot 中常⽤注解及其底层实现</h2><ol><li>@SpringBootApplication 注解：这个注解标识了⼀个 SpringBoot ⼯程，它实际上是另外三个注解<br>的组合，这三个注解是：<br>a. @SpringBootConfiguration：这个注解实际就是⼀个 @Configuration，表示启动类也是⼀个<br>配置类<br>b. @EnableAutoConfiguration：向 Spring 容器中导⼊了⼀个 Selector，⽤来加载 ClassPath 下<br>SpringFactories 中所定义的⾃动配置类，将这些⾃动加载为配置 Bean<br>c. @ComponentScan：标识扫描路径，因为默认是没有配置实际扫描路径，所以 SpringBoot 扫<br>描的路径是启动类所在的当前⽬录</li><li>@Bean 注解：⽤来定义 Bean，类似于 XML 中的 &lt;bean&gt; 标签，Spring 在启动时，会对加了 @Bean 注<br>解的⽅法进⾏解析，将⽅法的名字做为 beanName，并通过执⾏⽅法得到 bean 对象</li><li>@Controller、@Service、@ResponseBody、@Autowired 都可以说</li></ol><h2 id="springboot是如何启动tomcat的"><a class="anchor" href="#springboot是如何启动tomcat的">#</a> SpringBoot 是如何启动 Tomcat 的</h2><ol><li>⾸先，SpringBoot 在启动时会先创建⼀个 Spring 容器</li><li>在创建 Spring 容器过程中，会利⽤ @ConditionalOnClass 技术来判断当前 classpath 中是否存在<br>Tomcat 依赖，如果存在则会⽣成⼀个启动 Tomcat 的 Bean</li><li>Spring 容器创建完之后，就会获取启动 Tomcat 的 Bean，并创建 Tomcat 对象，并绑定端⼝等，然后<br>启动 Tomcat</li></ol><h2 id="mybatis存在哪些优点和缺点"><a class="anchor" href="#mybatis存在哪些优点和缺点">#</a> Mybatis 存在哪些优点和缺点</h2><p>优点：</p><ol><li>基于 SQL 语句编程，相当灵活，不会对应⽤程序或者数据库的现有设计造成任何影响，SQL 单独<br>写，解除 sql 与程序代码的耦合，便于统⼀管理。</li><li>与 JDBC 相⽐，减少了 50% 以上的代码量，消除了 JDBC ⼤量冗余的代码，不需要⼿动开关连<br>接；</li><li>很好的与各种数据库兼容（ 因为 MyBatis 使⽤ JDBC 来连接数据库，所以只要 JDBC ⽀持的数据<br>库 MyBatis 都⽀持）。</li><li>能够与 Spring 很好的集成；</li><li>提供映射标签， ⽀持对象与数据库的 ORM 字段关系映射； 提供对象关系映射标签， ⽀持对象关<br>系组件维护。</li></ol><h2 id="mybatis中和的区别是什么"><a class="anchor" href="#mybatis中和的区别是什么">#</a> Mybatis 中 #{} 和 ${} 的区别是什么？</h2><ol><li>#{} 是预编译处理、是占位符， ${} 是字符串替换、是拼接符</li><li>Mybatis 在处理 #{} 时，会将 sql 中的 #{} 替换为？号，调⽤ PreparedStatement 来赋值</li><li>Mybatis 在处理<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mrow></mrow><mtext>时，就是把</mtext></mrow><annotation encoding="application/x-tex">{}时， 就是把</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:.68333em;vertical-align:0"></span><span class="mord"></span><span class="mord cjk_fallback">时</span><span class="mord cjk_fallback">，</span><span class="mord cjk_fallback">就</span><span class="mord cjk_fallback">是</span><span class="mord cjk_fallback">把</span></span></span></span> {} 替换成变量的值，调⽤ Statement 来赋值</li><li>使⽤ #{} 可以有效的防⽌ SQL 注⼊，提⾼系统安全性</li></ol><p><img data-src="../../assets/image-20210804165002553.png" alt="image-20210804165002553"></p><h2 id="什么是cap理论"><a class="anchor" href="#什么是cap理论">#</a> 什么是 CAP 理论</h2><p>CAP 理论是分布式领域中⾮常重要的⼀个指导理论，C（Consistency）表示强⼀致性， A（Availability）表示可⽤性，P（Partition Tolerance）表示分区容错性，CAP 理论指出在⽬前的硬件 条件下，⼀个分布式系统是必须要保证分区容错性的，⽽在这个前提下，分布式系统要么保证 CP，要么 保证 AP，⽆法同时保证 CAP。</p><p>分区容错性表示，⼀个系统虽然是分布式的，但是对外看上去应该是⼀个整体，不能由于分布式系统内 部的某个结点挂点，或⽹络出现了故障，⽽导致系统对外出现异常。所以，对于分布式系统⽽⾔是⼀定 要保证分区容错性的。</p><p>强⼀致性表示，⼀个分布式系统中各个结点之间能及时的同步数据，在数据同步过程中，是不能对外提 供服务的，不然就会造成数据不⼀致，所以强⼀致性和可⽤性是不能同时满⾜的。</p><p>可⽤性表示，⼀个分布式系统对外要保证可⽤。</p><h2 id="什么是base理论"><a class="anchor" href="#什么是base理论">#</a> 什么是 BASE 理论</h2><p>由于不能同时满⾜ CAP，所以出现了 BASE 理论：</p><ol><li>BA：Basically Available，表示基本可⽤，表示可以允许⼀定程度的不可⽤，⽐如由于系统故障，<br>请求时间变⻓，或者由于系统故障导致部分⾮核⼼功能不可⽤，都是允许的</li><li>S：Soft state：表示分布式系统可以处于⼀种中间状态，⽐如数据正在同步</li><li>E：Eventually consistent，表示最终⼀致性，不要求分布式系统数据实时达到⼀致，允许在经过⼀<br>段时间后再达到⼀致，在达到⼀致过程中，系统也是可⽤的</li></ol><h2 id="什么是rpc"><a class="anchor" href="#什么是rpc">#</a> 什么是 RPC</h2><p>RPC，表示远程过程调⽤，对于 Java 这种⾯试对象语⾔，也可以理解为<strong>远程⽅法调⽤</strong>，RPC 调⽤和 HTTP 调⽤是有区别的，RPC 表示的是⼀种调⽤远程⽅法的⽅式，可以使⽤ HTTP 协议、或直接基于 TCP 协议来实现 RPC，在 Java 中，我们可以通过直接使⽤某个服务接⼝的代理对象来执⾏⽅法，⽽底层则通 过构造 HTTP 请求来调⽤远端的⽅法，所以，有⼀种说法是 RPC 协议是 HTTP 协议之上的⼀种协议，也是 可以理解的。</p><h2 id="分布式id是什么有哪些解决方案"><a class="anchor" href="#分布式id是什么有哪些解决方案">#</a> 分布式 ID 是什么？有哪些解决⽅案？</h2><p>在开发中，我们通常会需要⼀个唯⼀ ID 来标识数据，如果是单体架构，我们可以通过数据库的主键，或<br>直接在内存中维护⼀个⾃增数字来作为 ID 都是可以的，但对于⼀个分布式系统，就会有可能会出现 ID 冲<br>什么是 CAP 理论<br>什么是 BASE 理论<br>什么是 RPC<br>分布式 ID 是什么？有哪些解决⽅案？<br>22<br>突，此时有以下解决⽅案：</p><ol><li>uuid，这种⽅案复杂度最低，但是会影响存储空间和性能</li><li>利⽤单机数据库的⾃增主键，作为分布式 ID 的⽣成器，复杂度适中，ID ⻓度较之 uuid 更短，但是受<br>到单机数据库性能的限制，并发量⼤的时候，此⽅案也不是最优⽅案</li><li>利⽤ redis、zookeeper 的特性来⽣成 id，⽐如 redis 的⾃增命令、zookeeper 的顺序节点，这种⽅案<br>和单机数据库 (mysql) 相⽐，性能有所提⾼，可以适当选⽤</li><li>雪花算法，⼀切问题如果能直接⽤算法解决，那就是最合适的，利⽤雪花算法也可以⽣成分布式<br>ID，底层原理就是通过某台机器在某⼀毫秒内对某⼀个数字⾃增，这种⽅案也能保证分布式架构中<br>的系统 id 唯⼀，但是只能保证趋势递增。业界存在 tinyid、leaf 等开源中间件实现了雪花算法。</li></ol><h2 id="分布式锁的使用场景是什么有哪些实现方案"><a class="anchor" href="#分布式锁的使用场景是什么有哪些实现方案">#</a> 分布式锁的使⽤场景是什么？有哪些实现⽅案？</h2><p>在单体架构中，多个线程都是属于同⼀个进程的，所以在线程并发执⾏时，遇到资源竞争时，可以利⽤<br>ReentrantLock、synchronized 等技术来作为锁，来控制共享资源的使⽤。</p><p>⽽在分布式架构中，多个线程是可能处于不同进程中的，⽽这些线程并发执⾏遇到资源竞争时，利⽤<br>ReentrantLock、synchronized 等技术是没办法来控制多个进程中的线程的，所以需要分布式锁，意思<br>就是，需要⼀个分布式锁⽣成器，分布式系统中的应⽤程序都可以来使⽤这个⽣成器所提供的锁，从⽽<br>达到多个进程中的线程使⽤同⼀把锁。</p><p>⽬前主流的分布式锁的实现⽅案有两种：</p><ol><li>zookeeper：利⽤的是 zookeeper 的临时节点、顺序节点、watch 机制来实现的，zookeeper 分布式<br>锁的特点是⾼⼀致性，因为 zookeeper 保证的是 CP，所以由它实现的分布式锁更可靠，不会出现混<br>乱</li><li>redis：利⽤ redis 的 setnx、lua 脚本、消费订阅等机制来实现的，redis 分布式锁的特点是⾼可⽤，<br>因为 redis 保证的是 AP，所以由它实现的分布式锁可能不可靠，不稳定（⼀旦 redis 中的数据出现了<br>不⼀致），可能会出现多个客户端同时加到锁的情况</li></ol><h2 id="spring-cloud有哪些常用组件作用是什么"><a class="anchor" href="#spring-cloud有哪些常用组件作用是什么">#</a> Spring Cloud 有哪些常⽤组件，作⽤是什么？</h2><ol><li>Eureka：注册中⼼</li><li>Nacos：注册中⼼、配置中⼼</li><li>Consul：注册中⼼、配置中⼼</li><li>Spring Cloud Config：配置中⼼</li><li>Feign/OpenFeign：RPC 调⽤</li><li>Kong：服务⽹关</li><li>Zuul：服务⽹关</li><li>Spring Cloud Gateway：服务⽹关</li><li>Ribbon：负载均衡</li><li>Spring CLoud Sleuth：链路追踪</li><li>Zipkin：链路追踪</li><li>Seata：分布式事务</li><li>Dubbo：RPC 调⽤</li><li>Sentinel：服务熔断</li><li>Hystrix：服务熔断</li></ol><h2 id="什么是服务雪崩什么是服务限流"><a class="anchor" href="#什么是服务雪崩什么是服务限流">#</a> 什么是服务雪崩？什么是服务限流？</h2><ol><li>当服务 A 调⽤服务 B，服务 B 调⽤ C，此时⼤量请求突然请求服务 A，假如服务 A 本身能抗住这些请<br>求，但是如果服务 C 抗不住，导致服务 C 请求堆积，从⽽服务 B 请求堆积，从⽽服务 A 不可⽤，这就<br>是服务雪崩，解决⽅式就是服务降级和服务熔断。</li><li>服务限流是指在⾼并发请求下，为了保护系统，可以对访问服务的请求进⾏数量上的限制，从⽽防<br>⽌系统不被⼤量请求压垮，在秒杀中，限流是⾮常重要的。</li></ol><h2 id="什么是服务熔断什么是服务降级区别是什么"><a class="anchor" href="#什么是服务熔断什么是服务降级区别是什么">#</a> 什么是服务熔断？什么是服务降级？区别是什么？</h2><ol><li>服务熔断是指，当服务 A 调⽤的某个服务 B 不可⽤时，上游服务 A 为了保证⾃⼰不受影响，从⽽不再<br>调⽤服务 B，直接返回⼀个结果，减轻服务 A 和服务 B 的压⼒，直到服务 B 恢复。</li><li>服务降级是指，当发现系统压⼒过载时，可以通过关闭某个服务，或限流某个服务来减轻系统压<br>⼒，这就是服务降级。</li></ol><pre><code>相同点：
1. 都是为了防⽌系统崩溃
2. 都让⽤户体验到某些功能暂时不可⽤
不同点：熔断是下游服务故障触发的，降级是为了降低系统负载
</code></pre><h2 id="bio-nio-aio分别是什么"><a class="anchor" href="#bio-nio-aio分别是什么">#</a> BIO、NIO、AIO 分别是什么</h2><ol><li>BIO：同步阻塞 IO，使⽤ BIO 读取数据时，线程会阻塞住，并且需要线程主动去查询是否有数据可<br>读，并且需要处理完⼀个 Socket 之后才能处理下⼀个 Socket</li><li>NIO：同步⾮阻塞 IO，使⽤ NIO 读取数据时，线程不会阻塞，但需要线程主动的去查询是否有 IO 事件</li><li>AIO：也叫做 NIO 2.0，异步⾮阻塞 IO，使⽤ AIO 读取数据时，线程不会阻塞，并且当有数据可读时<br>会通知给线程，不需要线程主动去查询</li></ol><h2 id="零拷是什么"><a class="anchor" href="#零拷是什么">#</a> 零拷⻉是什么</h2><p>零拷⻉指的是，应⽤程序在需要把内核中的⼀块区域数据转移到另外⼀块内核区域去时，不需要经过先 复制到⽤户空间，再转移到⽬标内核区域去了，⽽直接实现转移。</p><p><img data-src="../../assets/image-20210804210529492.png" alt="image-20210804210529492"></p><h3 id="netty是什么和tomcat有什么区别特点是什么"><a class="anchor" href="#netty是什么和tomcat有什么区别特点是什么">#</a> Netty 是什么？和 Tomcat 有什么区别？特点是什么？</h3><p>Netty 是⼀个基于 NIO 的异步⽹络通信框架，性能⾼，封装了原⽣ NIO 编码的复杂度，开发者可以直接使<br>⽤ Netty 来开发⾼效率的各种⽹络服务器，并且编码简单。<br>Tomcat 是⼀个 Web 服务器，是⼀个 Servlet 容器，基本上 Tomcat 内部只会运⾏ Servlet 程序，并处理<br>HTTP 请求，⽽ Netty 封装的是底层 IO 模型，关注的是⽹络数据的传输，⽽不关⼼具体的协议，可定制性<br>更⾼。</p><p>Netty 的特点：</p><ol><li>异步、NIO 的⽹络通信框架</li><li>⾼性能</li><li>⾼扩展，⾼定制性</li><li>易⽤性</li></ol><h2 id="netty的高性能体现在哪些方面"><a class="anchor" href="#netty的高性能体现在哪些方面">#</a> Netty 的⾼性能体现在哪些⽅⾯</h2><ol><li>NIO 模型，⽤最少的资源做更多的事情。</li><li>内存零拷⻉，尽量减少不必要的内存拷⻉，实现了更⾼效率的传输。</li><li>内存池设计，申请的内存可以重⽤，主要指直接内存。内部实现是⽤⼀颗⼆叉查找树管理内存分配<br>情况。</li><li>串⾏化处理读写 ：避免使⽤锁带来的性能开销。即消息的处理尽可能再同⼀个线程内完成，期间不<br>进⾏线程切换，这样就避免了多线程竞争和同步锁。表⾯上看，串⾏化设计似乎 CPU 利⽤率不⾼，<br>并发程度不够。但是，通过调整 NIO 线程池的线程参数，可以同时启动多个串⾏化的线程并⾏运<br>⾏，这种局部⽆锁化的串⾏线程设计相⽐⼀个队⾥ - 多个⼯作线程模型性能更优。</li><li>⾼性能序列化协议 ：⽀持 protobuf 等⾼性能序列化协议。</li><li>⾼效并发编程的体现 ：volatile 的⼤量、正确使⽤；CAS 和原⼦类的⼴泛使⽤；线程安全容器的使⽤；通过读写锁提升并发性能。</li></ol><h2 id="redis有哪些数据结构分别有哪些典型的应用场景"><a class="anchor" href="#redis有哪些数据结构分别有哪些典型的应用场景">#</a> Redis 有哪些数据结构？分别有哪些典型的应⽤场景？</h2><p>Redis 的数据结构有：</p><ol><li>字符串：可以⽤来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个 json 格式的字符<br>串，Redis 分布式锁的实现就利⽤了这种数据结构，还包括可以实现计数器、Session 共享、分布式<br>ID</li><li>哈希表：可以⽤来存储⼀些 key-value 对，更适合⽤来存储对象</li><li>列表：Redis 的列表通过命令的组合，既可以当做栈，也可以当做队列来使⽤，可以⽤来缓存类似<br>微信公众号、微博等消息流数据</li><li>集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进⾏交集、并集、差集操作，<br>从⽽可以实现类似，我和某⼈共同关注的⼈、朋友圈点赞等功能</li><li>有序集合：集合是⽆序的，有序集合可以设置顺序，可以⽤来实现排⾏榜功能</li></ol><h2 id="redis分布式锁底层是如何实现的"><a class="anchor" href="#redis分布式锁底层是如何实现的">#</a> Redis 分布式锁底层是如何实现的？</h2><ol><li>⾸先利⽤ setnx 来保证：如果 key 不存在才能获取到锁，如果 key 存在，则获取不到锁</li><li>然后还要利⽤ lua 脚本来保证多个 redis 操作的原⼦性</li><li>同时还要考虑到锁过期，所以需要额外的⼀个看⻔狗定时任务来监听锁是否需要续约</li><li>同时还要考虑到 redis 节点挂掉后的情况，所以需要采⽤红锁的⽅式来同时向 N/2+1 个节点申请锁，<br>都申请到了才证明获取锁成功，这样就算其中某个 redis 节点挂掉了，锁也不能被其他客户端获取到</li></ol><h2 id="redis主从复制的核心原理"><a class="anchor" href="#redis主从复制的核心原理">#</a> Redis 主从复制的核⼼原理</h2><p>Redis 的主从复制是提⾼ Redis 的可靠性的有效措施，主从复制的流程如下：</p><ol><li>集群启动时，主从库间会先建⽴连接，为全量复制做准备</li><li>主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载，这个过程依赖于内存快照<br>RDB</li><li>在主库将数据同步给从库的过程中，主库不会阻塞，仍然可以正常接收请求。否则，redis 的服务就被中断<br>了。但是，这些请求中的写操作并没有记录到刚刚⽣成的 RDB ⽂件中。为了保证主从库的数据⼀致性，主<br>库会在内存中⽤专⻔的 replication buffer，记录 RDB ⽂件⽣成收到的所有写操作。</li><li>最后，也就是第三个阶段，主库会把第⼆阶段执⾏过程中新收到的写命令，再发送给从库。具体的操作<br>是，当主库完成 RDB ⽂件发送后，就会把此时 replocation buffer 中修改操作发送给从库，从库再执⾏这些<br>操作。这样⼀来，主从库就实现同步了</li><li>后续主库和从库都可以处理客户端读操作，写操作只能交给主库处理，主库接收到写操作后，还会将写操<br>作发送给从库，实现增量同步</li></ol><h2 id="缓存穿透-缓存击穿-缓存雪崩分别是什么"><a class="anchor" href="#缓存穿透-缓存击穿-缓存雪崩分别是什么">#</a> 缓存穿透、缓存击穿、缓存雪崩分别是什么</h2><p>缓存中存放的⼤多都是热点数据，⽬的就是防⽌请求可以直接从缓存中获取到数据，⽽不⽤访问 Mysql。</p><ol><li>缓存雪崩：如果缓存中某⼀时刻⼤批热点数据同时过期，那么就可能导致⼤量请求直接访问 Mysql<br>了，解决办法就是在过期时间上增加⼀点随机值，另外如果搭建⼀个⾼可⽤的 Redis 集群也是防⽌<br>缓存雪崩的有效⼿段</li><li>缓存击穿：和缓存雪崩类似，缓存雪崩是⼤批热点数据失效，⽽缓存击穿是指某⼀个热点 key 突然<br>失效，也导致了⼤量请求直接访问 Mysql 数据库，这就是缓存击穿，解决⽅案就是考虑这个热点 key<br>不设过期时间</li><li>缓存穿透：假如某⼀时刻访问 redis 的⼤量 key 都在 redis 中不存在（⽐如⿊客故意伪造⼀些乱七⼋糟<br>的 key），那么也会给数据造成压⼒，这就是缓存穿透，解决⽅案是使⽤布隆过滤器，它的作⽤就<br>是如果它认为⼀个 key 不存在，那么这个 key 就肯定不存在，所以可以在缓存之前加⼀层布隆过滤器<br>来拦截不存在的 key</li></ol><h2 id="redis和mysql如何保证数据一致"><a class="anchor" href="#redis和mysql如何保证数据一致">#</a> Redis 和 Mysql 如何保证数据⼀致</h2><ol><li>先更新 Mysql，再更新 Redis，如果更新 Redis 失败，可能仍然不⼀致</li><li>先删除 Redis 缓存数据，再更新 Mysql，再次查询的时候在将数据添加到缓存中，这种⽅案能解决 1<br>⽅案的问题，但是在⾼并发下性能较低，⽽且仍然会出现数据不⼀致的问题，⽐如线程 1 删除了<br>Redis 缓存数据，正在更新 Mysql，此时另外⼀个查询再查询，那么就会把 Mysql 中⽼数据⼜查到<br>Redis 中</li><li>延时双删，步骤是：先删除 Redis 缓存数据，再更新 Mysql，延迟⼏百毫秒再删除 Redis 缓存数据，<br>这样就算在更新 Mysql 时，有其他线程读了 Mysql，把⽼数据读到了 Redis 中，那么也会被删除掉，<br>从⽽把数据保持⼀致</li></ol><h2 id="explain语句结果中各个字段分表表示什么"><a class="anchor" href="#explain语句结果中各个字段分表表示什么">#</a> Explain 语句结果中各个字段分表表示什么</h2><p><img data-src="../../assets/image-20210804214815365.png" alt="image-20210804214815365"></p><h2 id="索引覆盖是什么"><a class="anchor" href="#索引覆盖是什么">#</a> 索引覆盖是什么</h2><p>索引覆盖就是⼀个 SQL 在执⾏时，可以利⽤索引来快速查找，并且此 SQL 所要查询的字段在当前索引对 应的字段中都包含了，那么就表示此 SQL ⾛完索引后不⽤回表了，所需要的字段都在当前索引的叶⼦节 点上存在，可以直接作为结果返回了</p><h2 id="最左前缀原则是什么"><a class="anchor" href="#最左前缀原则是什么">#</a> 最左前缀原则是什么</h2><p>当⼀个 SQL 想要利⽤索引是，就⼀定要提供该索引所对应的字段中最左边的字段，也就是排在最前⾯的 字段，⽐如针对 a,b,c 三个字段建⽴了⼀个联合索引，那么在写⼀个 sql 时就⼀定要提供 a 字段的条件，这 样才能⽤到联合索引，这是由于在建⽴ a,b,c 三个字段的联合索引时，底层的 B + 树是按照 a,b,c 三个字段 从左往右去⽐较⼤⼩进⾏排序的，所以如果想要利⽤ B + 树进⾏快速查找也得符合这个规则</p><h2 id="innodb是如何实现事务的"><a class="anchor" href="#innodb是如何实现事务的">#</a> Innodb 是如何实现事务的</h2><p>Innodb 通过 Buffer Pool，LogBuffer，Redo Log，Undo Log 来实现事务，以⼀个 update 语句为例：</p><ol><li>Innodb 在收到⼀个 update 语句后，会先根据条件找到数据所在的⻚，并将该⻚缓存在 Buffer Pool<br>中</li><li>执⾏ update 语句，修改 Buffer Pool 中的数据，也就是内存中的数据</li><li>针对 update 语句⽣成⼀个 RedoLog 对象，并存⼊ LogBuffer 中</li><li>针对 update 语句⽣成 undolog ⽇志，⽤于事务回滚</li><li>如果事务提交，那么则把 RedoLog 对象进⾏持久化，后续还有其他机制将 Buffer Pool 中所修改的<br>数据⻚持久化到磁盘中</li><li>如果事务回滚，则利⽤ undolog ⽇志进⾏回滚</li></ol><h2 id="b树和b树的区别为什么mysql使用b树"><a class="anchor" href="#b树和b树的区别为什么mysql使用b树">#</a> B 树和 B + 树的区别，为什么 Mysql 使⽤ B + 树</h2><p>B 树的特点：</p><ol><li>节点排序</li><li>⼀个节点了可以存多个元素，多个元素也排序了<br>B + 树的特点：</li><li>拥有 B 树的特点</li><li>叶⼦节点之间有指针</li><li>⾮叶⼦节点上的元素在叶⼦节点上都冗余了，也就是叶⼦节点中存储了所有的元素，并且排好顺序<br>Mysql 索引使⽤的是 B + 树，因为索引是⽤来加快查询的，⽽ B + 树通过对数据进⾏排序所以是可以提⾼查<br>询速度的，然后通过⼀个节点中可以存储多个元素，从⽽可以使得 B + 树的⾼度不会太⾼，在 Mysql 中⼀<br>个 Innodb ⻚就是⼀个 B + 树节点，⼀个 Innodb ⻚默认 16kb，所以⼀般情况下⼀颗两层的 B + 树可以存 2000<br>万⾏左右的数据，然后通过利⽤ B + 树叶⼦节点存储了所有数据并且进⾏了排序，并且叶⼦节点之间有指<br>针，可以很好的⽀持全表扫描，范围查找等 SQL 语句。</li></ol><h2 id="mysql锁有哪些如何理解"><a class="anchor" href="#mysql锁有哪些如何理解">#</a> Mysql 锁有哪些，如何理解</h2><p>按锁粒度分类：</p><ol><li>⾏锁：锁某⾏数据，锁粒度最⼩，并发度⾼</li><li>表锁：锁整张表，锁粒度最⼤，并发度低</li><li>间隙锁：锁的是⼀个区间<br>还可以分为：</li><li>共享锁：也就是读锁，⼀个事务给某⾏数据加了读锁，其他事务也可以读，但是不能写</li><li>排它锁：也就是写锁，⼀个事务给某⾏数据加了写锁，其他事务不能读，也不能写<br>还可以分为：</li><li>乐观锁：并不会真正的去锁某⾏记录，⽽是通过⼀个版本号来实现的</li><li>悲观锁：上⾯所的⾏锁、表锁等都是悲观锁<br>在事务的隔离级别实现中，就需要利⽤锁来解决幻读</li></ol><h2 id="mysql慢查询该如何优化"><a class="anchor" href="#mysql慢查询该如何优化">#</a> Mysql 慢查询该如何优化？</h2><ol><li>检查是否⾛了索引，如果没有则优化 SQL 利⽤索引</li><li>检查所利⽤的索引，是否是最优索引</li><li>检查所查字段是否都是必须的，是否查询了过多字段，查出了多余数据</li><li>检查表中数据是否过多，是否应该进⾏分库分表了</li><li>检查数据库实例所在机器的性能配置，是否太低，是否可以适当增加资源</li></ol><h2 id="消息队列有哪些作用"><a class="anchor" href="#消息队列有哪些作用">#</a> 消息队列有哪些作⽤</h2><ol><li>解耦：使⽤消息队列来作为两个系统之间的通讯⽅式，两个系统不需要相互依赖了</li><li>异步：系统 A 给消息队列发送完消息之后，就可以继续做其他事情了</li><li>流量削峰：如果使⽤消息队列的⽅式来调⽤某个系统，那么消息将在队列中排队，由消费者⾃⼰控<br>制消费速度</li></ol><h2 id="死信队列是什么延时队列是什么"><a class="anchor" href="#死信队列是什么延时队列是什么">#</a> 死信队列是什么？延时队列是什么？</h2><ol><li>死信队列也是⼀个消息队列，它是⽤来存放那些没有成功消费的消息的，通常可以⽤来作为消息重<br>试</li><li>延时队列就是⽤来存放需要在指定时间被处理的元素的队列，通常可以⽤来处理⼀些具有过期性操<br>作的业务，⽐如⼗分钟内未⽀付则取消订单</li></ol><div class="tags"><a href="/tags/java/" rel="tag"><i class="ic i-tag"></i> java</a> <a href="/tags/interview/" rel="tag"><i class="ic i-tag"></i> interview</a></div></div><footer><div class="meta"><span class="item"><span class="icon"><i class="ic i-calendar-check"></i> </span><span class="text">更新于</span> <time title="修改时间：2022-06-03 16:55:51" itemprop="dateModified" datetime="2022-06-03T16:55:51+08:00">2022-06-03</time> </span><span id="worknote/Interview-2/" class="item leancloud_visitors" data-flag-title="面试题笔记记录(二)面试必考题（通俗易懂精华版）" title="阅读次数"><span class="icon"><i class="ic i-eye"></i> </span><span class="text">阅读次数</span> <span class="leancloud-visitors-count"></span> <span class="text">次</span></span></div><div class="reward"><button><i class="ic i-heartbeat"></i> 赞赏</button><p>请我喝[茶]~(￣▽￣)~*</p><div id="qr"><div><img data-src="/images/wechatpay.png" alt="WangXuefeng 微信支付"><p>微信支付</p></div><div><img data-src="/images/alipay.png" alt="WangXuefeng 支付宝"><p>支付宝</p></div><div><img data-src="/images/paypal.png" alt="WangXuefeng 贝宝"><p>贝宝</p></div></div></div><div id="copyright"><ul><li class="author"><strong>本文博主： </strong>WangXuefeng <i class="ic i-at"><em>@</em></i></li><li class="link"><strong>本文链接：</strong> <a href="https://oxyzen-wxf.github.io/worknote/Interview-2/" title="面试题笔记记录(二)面试必考题（通俗易懂精华版）">https://oxyzen-wxf.github.io/worknote/Interview-2/</a></li><li class="license"><strong>版权声明： </strong>本站所有文章除特别声明外，均采用 <span class="exturl" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC9kZWVkLnpo"><i class="ic i-creative-commons"><em>(CC)</em></i>BY-NC-SA</span> 许可协议。转载请注明出处！</li></ul></div></footer></article></div><div class="post-nav"><div class="item left"><a href="/worknote/digui-1/" itemprop="url" rel="prev" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gicitzannuj20zk0m8b29.jpg" title="递归解决权限树或多级联动的两种方法"><span class="type">上一篇</span> <span class="category"><i class="ic i-flag"></i> Java常用工具</span><h3>递归解决权限树或多级联动的两种方法</h3></a></div><div class="item right"><a href="/worknote/Interview-1/" itemprop="url" rel="next" data-background-image="https:&#x2F;&#x2F;tva3.sinaimg.cn&#x2F;mw690&#x2F;6833939bly1gipevgoki5j20zk0m84qp.jpg" title="面试题笔记记录(一)"><span class="type">下一篇</span> <span class="category"><i class="ic i-flag"></i> Java</span><h3>面试题笔记记录(一)</h3></a></div></div><div class="wrap" id="comments"></div></div><div id="sidebar"><div class="inner"><div class="panels"><div class="inner"><div class="contents panel pjax" data-title="文章目录"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%94%E8%AF%95"><span class="toc-number">1.</span> <span class="toc-text">笔试</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%8B%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98%E4%B8%80"><span class="toc-number">1.1.</span> <span class="toc-text">看一下代码回答问题（一）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%8B%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98%E4%BA%8C"><span class="toc-number">1.2.</span> <span class="toc-text">看一下代码回答问题（二）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9C%8B%E4%B8%80%E4%B8%8B%E4%BB%A3%E7%A0%81%E5%9B%9E%E7%AD%94%E9%97%AE%E9%A2%98%E4%B8%89"><span class="toc-number">1.3.</span> <span class="toc-text">看一下代码回答问题（三）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string-stringbuffer-stringbuilder%E5%8C%BA%E5%88%AB"><span class="toc-number">2.</span> <span class="toc-text">String、StringBuffer、StringBuilder 区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#arraylist%E5%92%8Clinkedlist%E6%9C%89%E5%93%AA%E4%BA%9B%E5%8C%BA%E5%88%AB"><span class="toc-number">3.</span> <span class="toc-text">ArrayList 和 LinkedList 有哪些区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#copyonwritearraylist%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">4.</span> <span class="toc-text">CopyOnWriteArrayList 的底层原理是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E4%B8%ADput%E6%96%B9%E6%B3%95%E7%9A%84%E8%BF%87%E7%A8%8B"><span class="toc-number">5.</span> <span class="toc-text">HashMap 中 put 方法的过程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E7%BA%A2%E9%BB%91%E6%A0%91%E7%9A%84%E8%A7%81%E8%A7%A3"><span class="toc-number">6.</span> <span class="toc-text">说说你对红黑树的见解？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmaplinkedhashmaptreemap%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">7.</span> <span class="toc-text">HashMap,LinkedHashMap,TreeMap 有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#hashmap%E5%BE%85%E7%BB%AD"><span class="toc-number">8.</span> <span class="toc-text">HashMap 待续...</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#concurrenthashmap"><span class="toc-number">9.</span> <span class="toc-text">ConcurrentHashMap……</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#threadlocal%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">10.</span> <span class="toc-text">ThreadLocal 的底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3volatile%E5%85%B3%E9%94%AE%E5%AD%97"><span class="toc-number">11.</span> <span class="toc-text">如何理解 volatile 关键字</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reentrantlock%E4%B8%AD%E7%9A%84%E5%85%AC%E5%B9%B3%E9%94%81%E5%92%8C%E9%9D%9E%E5%85%AC%E5%B9%B3%E9%94%81%E7%9A%84%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">12.</span> <span class="toc-text">ReentrantLock 中的公平锁和⾮公平锁的底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#reentrantlock%E4%B8%ADtrylock%E5%92%8Clock%E6%96%B9%E6%B3%95%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">13.</span> <span class="toc-text">ReentrantLock 中 tryLock () 和 lock () ⽅法的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#countdownlatch%E5%92%8Csemaphore%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86"><span class="toc-number">14.</span> <span class="toc-text">CountDownLatch 和 Semaphore 的区别和底层原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sychronized%E7%9A%84%E5%81%8F%E5%90%91%E9%94%81-%E8%BD%BB%E9%87%8F%E7%BA%A7%E9%94%81-%E9%87%8D%E9%87%8F%E7%BA%A7%E9%94%81"><span class="toc-number">15.</span> <span class="toc-text">Sychronized 的偏向锁、轻量级锁、重量级锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#sychronized%E5%92%8Creentrantlock%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">16.</span> <span class="toc-text">Sychronized 和 ReentrantLock 的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86"><span class="toc-number">17.</span> <span class="toc-text">线程池的底层⼯作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm%E4%B8%AD%E5%93%AA%E4%BA%9B%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%85%B1%E4%BA%AB%E5%8C%BA"><span class="toc-number">18.</span> <span class="toc-text">JVM 中哪些是线程共享区</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#jvm%E4%B8%AD%E5%93%AA%E4%BA%9B%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAgc-root"><span class="toc-number">19.</span> <span class="toc-text">JVM 中哪些可以作为 gc root</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%B4%E8%AF%B4%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%A8%A1%E5%9E%8B"><span class="toc-number">20.</span> <span class="toc-text">说说类加载器双亲委派模型</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tomcat%E4%B8%AD%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%BD%BF%E7%94%A8%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%8A%A0%E8%BD%BD%E5%99%A8"><span class="toc-number">21.</span> <span class="toc-text">Tomcat 中为什么要使⽤⾃定义类加载器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#tomcat%E5%A6%82%E4%BD%95%E8%BF%9B%E8%A1%8C%E4%BC%98%E5%8C%96"><span class="toc-number">22.</span> <span class="toc-text">Tomcat 如何进⾏优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B5%8F%E8%A7%88%E5%99%A8%E5%8F%91%E5%87%BA%E4%B8%80%E4%B8%AA%E8%AF%B7%E6%B1%82%E5%88%B0%E6%94%B6%E5%88%B0%E5%93%8D%E5%BA%94%E7%BB%8F%E5%8E%86%E4%BA%86%E5%93%AA%E4%BA%9B%E6%AD%A5%E9%AA%A4"><span class="toc-number">23.</span> <span class="toc-text">浏览器发出⼀个请求到收到响应经历了哪些步骤？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%A8%E5%9F%9F%E8%AF%B7%E6%B1%82%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%E6%80%8E%E4%B9%88%E8%A7%A3%E5%86%B3"><span class="toc-number">24.</span> <span class="toc-text">跨域请求是什么？有什么问题？怎么解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E4%B8%AD%E7%9A%84bean%E5%88%9B%E5%BB%BA%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E6%9C%89%E5%93%AA%E4%BA%9B%E6%AD%A5%E9%AA%A4"><span class="toc-number">25.</span> <span class="toc-text">Spring 中的 Bean 创建的⽣命周期有哪些步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E4%B8%ADbean%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97"><span class="toc-number">26.</span> <span class="toc-text">Spring 中 Bean 是线程安全的吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#applicationcontext%E5%92%8Cbeanfactory%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB"><span class="toc-number">27.</span> <span class="toc-text">ApplicationContext 和 BeanFactory 有什么区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E4%B8%AD%E7%9A%84%E4%BA%8B%E5%8A%A1%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">28.</span> <span class="toc-text">Spring 中的事务是如何实现的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E4%B8%AD%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99transactional%E4%BC%9A%E5%A4%B1%E6%95%88"><span class="toc-number">29.</span> <span class="toc-text">Spring 中什么时候 @Transactional 会失效</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84"><span class="toc-number">30.</span> <span class="toc-text">Spring 容器启动流程是怎样的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring%E7%94%A8%E5%88%B0%E4%BA%86%E5%93%AA%E4%BA%9B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="toc-number">31.</span> <span class="toc-text">Spring ⽤到了哪些设计模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#springmvc%E7%9A%84%E5%BA%95%E5%B1%82%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="toc-number">32.</span> <span class="toc-text">SpringMVC 的底层⼯作流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-refresh"><span class="toc-number">33.</span> <span class="toc-text">Spring refresh</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#springboot%E4%B8%AD%E5%B8%B8%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%8F%8A%E5%85%B6%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-number">34.</span> <span class="toc-text">SpringBoot 中常⽤注解及其底层实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#springboot%E6%98%AF%E5%A6%82%E4%BD%95%E5%90%AF%E5%8A%A8tomcat%E7%9A%84"><span class="toc-number">35.</span> <span class="toc-text">SpringBoot 是如何启动 Tomcat 的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mybatis%E5%AD%98%E5%9C%A8%E5%93%AA%E4%BA%9B%E4%BC%98%E7%82%B9%E5%92%8C%E7%BC%BA%E7%82%B9"><span class="toc-number">36.</span> <span class="toc-text">Mybatis 存在哪些优点和缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mybatis%E4%B8%AD%E5%92%8C%E7%9A%84%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">37.</span> <span class="toc-text">Mybatis 中 #{} 和 ${} 的区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFcap%E7%90%86%E8%AE%BA"><span class="toc-number">38.</span> <span class="toc-text">什么是 CAP 理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFbase%E7%90%86%E8%AE%BA"><span class="toc-number">39.</span> <span class="toc-text">什么是 BASE 理论</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AFrpc"><span class="toc-number">40.</span> <span class="toc-text">什么是 RPC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8Fid%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E5%93%AA%E4%BA%9B%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88"><span class="toc-number">41.</span> <span class="toc-text">分布式 ID 是什么？有哪些解决⽅案？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E7%9A%84%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E6%98%AF%E4%BB%80%E4%B9%88%E6%9C%89%E5%93%AA%E4%BA%9B%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88"><span class="toc-number">42.</span> <span class="toc-text">分布式锁的使⽤场景是什么？有哪些实现⽅案？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#spring-cloud%E6%9C%89%E5%93%AA%E4%BA%9B%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">43.</span> <span class="toc-text">Spring Cloud 有哪些常⽤组件，作⽤是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E9%9B%AA%E5%B4%A9%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E9%99%90%E6%B5%81"><span class="toc-number">44.</span> <span class="toc-text">什么是服务雪崩？什么是服务限流？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E7%86%94%E6%96%AD%E4%BB%80%E4%B9%88%E6%98%AF%E6%9C%8D%E5%8A%A1%E9%99%8D%E7%BA%A7%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">45.</span> <span class="toc-text">什么是服务熔断？什么是服务降级？区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#bio-nio-aio%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">46.</span> <span class="toc-text">BIO、NIO、AIO 分别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9B%B6%E6%8B%B7%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">47.</span> <span class="toc-text">零拷⻉是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#netty%E6%98%AF%E4%BB%80%E4%B9%88%E5%92%8Ctomcat%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%E7%89%B9%E7%82%B9%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">47.1.</span> <span class="toc-text">Netty 是什么？和 Tomcat 有什么区别？特点是什么？</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#netty%E7%9A%84%E9%AB%98%E6%80%A7%E8%83%BD%E4%BD%93%E7%8E%B0%E5%9C%A8%E5%93%AA%E4%BA%9B%E6%96%B9%E9%9D%A2"><span class="toc-number">48.</span> <span class="toc-text">Netty 的⾼性能体现在哪些⽅⾯</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E6%9C%89%E5%93%AA%E4%BA%9B%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%86%E5%88%AB%E6%9C%89%E5%93%AA%E4%BA%9B%E5%85%B8%E5%9E%8B%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">49.</span> <span class="toc-text">Redis 有哪些数据结构？分别有哪些典型的应⽤场景？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81%E5%BA%95%E5%B1%82%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E7%9A%84"><span class="toc-number">50.</span> <span class="toc-text">Redis 分布式锁底层是如何实现的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E4%B8%BB%E4%BB%8E%E5%A4%8D%E5%88%B6%E7%9A%84%E6%A0%B8%E5%BF%83%E5%8E%9F%E7%90%86"><span class="toc-number">51.</span> <span class="toc-text">Redis 主从复制的核⼼原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BC%93%E5%AD%98%E7%A9%BF%E9%80%8F-%E7%BC%93%E5%AD%98%E5%87%BB%E7%A9%BF-%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9%E5%88%86%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">52.</span> <span class="toc-text">缓存穿透、缓存击穿、缓存雪崩分别是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#redis%E5%92%8Cmysql%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E6%95%B0%E6%8D%AE%E4%B8%80%E8%87%B4"><span class="toc-number">53.</span> <span class="toc-text">Redis 和 Mysql 如何保证数据⼀致</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#explain%E8%AF%AD%E5%8F%A5%E7%BB%93%E6%9E%9C%E4%B8%AD%E5%90%84%E4%B8%AA%E5%AD%97%E6%AE%B5%E5%88%86%E8%A1%A8%E8%A1%A8%E7%A4%BA%E4%BB%80%E4%B9%88"><span class="toc-number">54.</span> <span class="toc-text">Explain 语句结果中各个字段分表表示什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B4%A2%E5%BC%95%E8%A6%86%E7%9B%96%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">55.</span> <span class="toc-text">索引覆盖是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">56.</span> <span class="toc-text">最左前缀原则是什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#innodb%E6%98%AF%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E4%BA%8B%E5%8A%A1%E7%9A%84"><span class="toc-number">57.</span> <span class="toc-text">Innodb 是如何实现事务的</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#b%E6%A0%91%E5%92%8Cb%E6%A0%91%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%BA%E4%BB%80%E4%B9%88mysql%E4%BD%BF%E7%94%A8b%E6%A0%91"><span class="toc-number">58.</span> <span class="toc-text">B 树和 B + 树的区别，为什么 Mysql 使⽤ B + 树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E9%94%81%E6%9C%89%E5%93%AA%E4%BA%9B%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3"><span class="toc-number">59.</span> <span class="toc-text">Mysql 锁有哪些，如何理解</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mysql%E6%85%A2%E6%9F%A5%E8%AF%A2%E8%AF%A5%E5%A6%82%E4%BD%95%E4%BC%98%E5%8C%96"><span class="toc-number">60.</span> <span class="toc-text">Mysql 慢查询该如何优化？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%9C%89%E5%93%AA%E4%BA%9B%E4%BD%9C%E7%94%A8"><span class="toc-number">61.</span> <span class="toc-text">消息队列有哪些作⽤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AD%BB%E4%BF%A1%E9%98%9F%E5%88%97%E6%98%AF%E4%BB%80%E4%B9%88%E5%BB%B6%E6%97%B6%E9%98%9F%E5%88%97%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">62.</span> <span class="toc-text">死信队列是什么？延时队列是什么？</span></a></li></ol></div><div class="related panel pjax" data-title="系列文章"><ul><li><a href="/worknote/security-jwt-vue/amdin-back/" rel="bookmark" title="开发SpringBoot+Jwt+Vue的前后端分离后台管理系统VueAdmin - 后端笔记">开发SpringBoot+Jwt+Vue的前后端分离后台管理系统VueAdmin - 后端笔记</a></li><li><a href="/worknote/easypoi-1/" rel="bookmark" title="easypoi导出大量数据">easypoi导出大量数据</a></li><li><a href="/worknote/javautil/util-2/" rel="bookmark" title="JDBC增删改查">JDBC增删改查</a></li><li><a href="/worknote/javautil/util-1/" rel="bookmark" title="用于将汉语的数字转换为阿拉伯数字">用于将汉语的数字转换为阿拉伯数字</a></li><li><a href="/worknote/javautil/util-3/" rel="bookmark" title="文件进行重命名">文件进行重命名</a></li><li><a href="/worknote/javautil/util-4/" rel="bookmark" title="JDBC连接工具">JDBC连接工具</a></li><li><a href="/worknote/javautil/util-5/" rel="bookmark" title="判断对象中属性值是否全为空">判断对象中属性值是否全为空</a></li><li><a href="/worknote/javautil/util-7/" rel="bookmark" title="保留小数工具">保留小数工具</a></li><li><a href="/worknote/javautil/utli-6/" rel="bookmark" title="随机生成随机码工具">随机生成随机码工具</a></li><li><a href="/worknote/javautil/util-8/" rel="bookmark" title="驼峰转换工具">驼峰转换工具</a></li><li><a href="/worknote/easypoi-2/" rel="bookmark" title="easypoi导出复杂表">easypoi导出复杂表</a></li><li><a href="/worknote/Interview-1/" rel="bookmark" title="面试题笔记记录(一)">面试题笔记记录(一)</a></li><li class="active"><a href="/worknote/Interview-2/" rel="bookmark" title="面试题笔记记录(二)面试必考题（通俗易懂精华版）">面试题笔记记录(二)面试必考题（通俗易懂精华版）</a></li><li><a href="/worknote/digui-1/" rel="bookmark" title="递归解决权限树或多级联动的两种方法">递归解决权限树或多级联动的两种方法</a></li><li><a href="/worknote/interview-3/" rel="bookmark" title="面试题笔记记录(三)周阳尚硅谷版">面试题笔记记录(三)周阳尚硅谷版</a></li><li><a href="/worknote/interview-4/" rel="bookmark" title="面试总结之北京行">面试总结之北京行</a></li><li><a href="/worknote/note-2/" rel="bookmark" title="日常笔记之幂等性">日常笔记之幂等性</a></li><li><a href="/worknote/note-1/" rel="bookmark" title="日常笔记之Spring Boot配置指定配置类">日常笔记之Spring Boot配置指定配置类</a></li><li><a href="/worknote/order-1/" rel="bookmark" title="尚硅谷订单服务笔记">尚硅谷订单服务笔记</a></li><li><a href="/worknote/order-2/" rel="bookmark" title="尚硅谷订单服务笔记之整合支付">尚硅谷订单服务笔记之整合支付</a></li><li><a href="/worknote/gulinote/" rel="bookmark" title="谷粒商城笔记">谷粒商城笔记</a></li><li><a href="/worknote/swagger-1/" rel="bookmark" title="微服务整合公共Swagger2以及微服务引用公共模块没有填进容器">微服务整合公共Swagger2以及微服务引用公共模块没有填进容器</a></li><li><a href="/worknote/order-3/" rel="bookmark" title="尚硅谷订单服务笔记之秒杀">尚硅谷订单服务笔记之秒杀</a></li><li><a href="/worknote/jvm-1/" rel="bookmark" title="JVM(一)">JVM(一)</a></li><li><a href="/worknote/spring-cycle-1/" rel="bookmark" title="Spring循环依赖">Spring循环依赖</a></li><li><a href="/worknote/timing-1/" rel="bookmark" title="定时任务">定时任务</a></li><li><a href="/worknote/interface-safety-1/" rel="bookmark" title="接口安全性">接口安全性</a></li></ul></div><div class="overview panel" data-title="站点概览"><div class="author" itemprop="author" itemscope itemtype="http://schema.org/Person"><img class="image" itemprop="image" alt="WangXuefeng" data-src="/images/avatar.jpg"><p class="name" itemprop="name">WangXuefeng</p><div class="description" itemprop="description">日常学习 & 复习记录</div></div><nav class="state"><div class="item posts"><a href="/archives/"><span class="count">85</span> <span class="name">文章</span></a></div><div class="item categories"><a href="/categories/"><span class="count">25</span> <span class="name">分类</span></a></div><div class="item tags"><a href="/tags/"><span class="count">44</span> <span class="name">标签</span></a></div></nav><div class="social"><span class="exturl item github" data-url="aHR0cHM6Ly9naXRodWIuY29tL294eXplbi13eGY=" title="https:&#x2F;&#x2F;github.com&#x2F;oxyzen-wxf"><i class="ic i-github"></i></span> <span class="exturl item music" data-url="aHR0cHM6Ly9tdXNpYy4xNjMuY29tLyMvdXNlci9ob21lP2lkPTYwNzA2MDI0MQ==" title="https:&#x2F;&#x2F;music.163.com&#x2F;#&#x2F;user&#x2F;home?id&#x3D;607060241"><i class="ic i-cloud-music"></i></span> <span class="exturl item weibo" data-url="aHR0cHM6Ly93ZWliby5jb20veW91cm5hbWU=" title="https:&#x2F;&#x2F;weibo.com&#x2F;yourname"><i class="ic i-weibo"></i></span> <span class="exturl item email" data-url="bWFpbHRvOjk2MzIxMDczOEBxcS5jb20=" title="mailto:963210738@qq.com"><i class="ic i-envelope"></i></span></div><ul class="menu"><li class="item"><a href="/" rel="section"><i class="ic i-home"></i>首页</a></li><li class="item"><a href="/about/" rel="section"><i class="ic i-user"></i>关于</a></li><li class="item dropdown"><a href="javascript:void(0);"><i class="ic i-feather"></i>文章</a><ul class="submenu"><li class="item"><a href="/archives/" rel="section"><i class="ic i-list-alt"></i>归档</a></li><li class="item"><a href="/categories/" rel="section"><i class="ic i-th"></i>分类</a></li><li class="item"><a href="/tags/" rel="section"><i class="ic i-tags"></i>标签</a></li></ul></li></ul></div></div></div><ul id="quick"><li class="prev pjax"><a href="/worknote/digui-1/" rel="prev" title="上一篇"><i class="ic i-chevron-left"></i></a></li><li class="up"><i class="ic i-arrow-up"></i></li><li class="down"><i class="ic i-arrow-down"></i></li><li class="next pjax"><a href="/worknote/Interview-1/" rel="next" title="下一篇"><i class="ic i-chevron-right"></i></a></li><li class="percent"></li></ul></div></div><div class="dimmer"></div></div></main><footer id="footer"><div class="inner"><div class="widgets"><div class="rpost pjax"><h2>随机文章</h2><ul><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/designpattern/" title="分类于 设计模式">设计模式</a></div><span><a href="/computer-science/java/designpattern/design-11/" title="设计模式之组合模式">设计模式之组合模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/javaweb/" title="分类于 JavaWeb">JavaWeb</a></div><span><a href="/computer-science/java/javaweb/servlet-1/" title="JavaWeb三大组件之Servlet">JavaWeb三大组件之Servlet</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/database/" title="分类于 数据库">数据库</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/database/elasticsearch/" title="分类于 ElasticSearch">ElasticSearch</a></div><span><a href="/database/elasticsearch/es-1/" title="ElasticSearch学习笔记">ElasticSearch学习笔记</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/microservice/" title="分类于 微服务分布式">微服务分布式</a></div><span><a href="/computer-science/java/microservice/transaction-1/" title="分布式事务">分布式事务</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/designpattern/" title="分类于 设计模式">设计模式</a></div><span><a href="/computer-science/java/designpattern/design-12/" title="设计模式之组合模式">设计模式之组合模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/javascript/" title="分类于 JavaScript">JavaScript</a></div><span><a href="/computer-science/javascript/es6-1/" title="Es6简单回顾（一）">Es6简单回顾（一）</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/designpattern/" title="分类于 设计模式">设计模式</a></div><span><a href="/computer-science/java/designpattern/desgin-3/" title="设计模式之单例模式">设计模式之单例模式</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/worknote/" title="分类于 工作日常笔记">工作日常笔记</a> <i class="ic i-angle-right"></i> <a href="/categories/worknote/java/" title="分类于 Java">Java</a></div><span><a href="/worknote/note-1/" title="日常笔记之Spring Boot配置指定配置类">日常笔记之Spring Boot配置指定配置类</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/computer-science/" title="分类于 计算机科学">计算机科学</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/computer-science/java/microservice/" title="分类于 微服务分布式">微服务分布式</a></div><span><a href="/computer-science/java/microservice/oauth-2/" title="Guli认证服务笔记(二) 单点登录">Guli认证服务笔记(二) 单点登录</a></span></li><li class="item"><div class="breadcrumb"><a href="/categories/review/" title="分类于 复习回顾">复习回顾</a> <i class="ic i-angle-right"></i> <a href="/categories/review/java/" title="分类于 Java">Java</a> <i class="ic i-angle-right"></i> <a href="/categories/review/java/javahigh/" title="分类于 Java高级">Java高级</a></div><span><a href="/review/java/javahigh/thread-1/" title="多线程之生产者消费者（一）">多线程之生产者消费者（一）</a></span></li></ul></div><div><h2>最新评论</h2><ul class="leancloud-recent-comment"></ul></div></div><div class="status"><div class="copyright">&copy; 2010 – <span itemprop="copyrightYear">2022</span> <span class="with-love"><i class="ic i-sakura rotate"></i> </span><span class="author" itemprop="copyrightHolder">WangXuefeng @ Oxygen Anoxia</span></div><div class="count"><span class="post-meta-item-icon"><i class="ic i-chart-area"></i> </span><span title="站点总字数">631k 字</span> <span class="post-meta-divider">|</span> <span class="post-meta-item-icon"><i class="ic i-coffee"></i> </span><span title="站点阅读时长">9:34</span></div><div class="powered-by">基于 <span class="exturl" data-url="aHR0cHM6Ly9oZXhvLmlv">Hexo</span> & Theme.<span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FtZWhpbWUvaGV4by10aGVtZS1zaG9rYQ==">Shoka</span></div></div></div></footer></div><script data-config type="text/javascript">var LOCAL={path:"worknote/Interview-2/",favicon:{show:"（●´3｀●）やれやれだぜ",hide:"(´Д｀)大変だ！"},search:{placeholder:"文章搜索",empty:"关于 「 ${query} 」，什么也没搜到",stats:"${time} ms 内找到 ${hits} 条结果"},valine:{placeholder:"1. 提问前请先仔细阅读本文档⚡\n2. 页面显示问题💥，请提供控制台截图📸或者您的测试网址\n3. 其他任何报错💣，请提供详细描述和截图📸，文章为个人见解，有问题请评论指出，及时修改🙅‍，祝食用愉快💪"},fancybox:!0,copyright:'复制成功，转载请遵守 <i class="ic i-creative-commons"></i>BY-NC-SA 协议。',ignores:[function(e){return e.includes("#")},function(e){return new RegExp(LOCAL.path+"$").test(e)}]}</script><script src="https://cdn.polyfill.io/v2/polyfill.js"></script><script src="//cdn.jsdelivr.net/combine/npm/pace-js@1.0.2/pace.min.js,npm/pjax@0.2.8/pjax.min.js,npm/whatwg-fetch@3.4.0/dist/fetch.umd.min.js,npm/animejs@3.2.0/lib/anime.min.js,npm/algoliasearch@4/dist/algoliasearch-lite.umd.js,npm/instantsearch.js@4/dist/instantsearch.production.min.js,npm/lozad@1/dist/lozad.min.js,npm/quicklink@2/dist/quicklink.umd.js"></script><script src="/js/app.js?v=0.2.5"></script></body></html><!-- rebuild by hrmmi -->